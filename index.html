<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ulyra - Messagerie</title>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-storage-compat.js"></script>
    <!-- Cloudinary Upload Widget -->
    <script src="https://upload-widget.cloudinary.com/global/all.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .message {
            margin-bottom: 20px;
        }
    </style>
    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --accent: #f093fb;
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border: #3a3a3a;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideIn {
            from { transform: translateX(-100%); }
            to { transform: translateX(0); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes bounce {
            0%, 20%, 53%, 80%, 100% { transform: translate3d(0,0,0); }
            40%, 43% { transform: translate3d(0, -30px, 0); }
            70% { transform: translate3d(0, -15px, 0); }
            90% { transform: translate3d(0, -4px, 0); }
        }

        /* Auth Pages */
        .auth-container {
            display: flex;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .auth-card {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            max-width: 400px;
            width: 100%;
            animation: fadeIn 0.8s ease-out;
        }

        .logo {
            text-align: center;
            margin-bottom: 30px;
        }

        .logo h1 {
            font-size: 3rem;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
            animation: pulse 2s infinite;
        }

        .logo p {
            color: var(--text-secondary);
            margin-top: 10px;
            font-size: 1.1rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .form-control {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-decoration: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            width: 100%;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .auth-switch {
            text-align: center;
            margin-top: 20px;
        }

        .auth-switch button {
            background: none;
            border: none;
            color: var(--primary);
            cursor: pointer;
            text-decoration: underline;
            font-size: 16px;
        }

        /* Main App */
        .app-container {
            display: none;
            height: 100vh;
            overflow: hidden;
        }

        .app-header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            z-index: 100;
        }

        .app-title {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-id {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-family: 'Courier New', monospace;
            font-weight: 600;
            color: var(--accent);
        }

        .app-body {
            display: flex;
            height: calc(100vh - 80px);
        }

        .sidebar {
            width: 350px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            animation: slideIn 0.5s ease-out;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-actions {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            padding: 10px 15px;
            font-size: 14px;
            border-radius: 8px;
        }

        .conversations-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .conversation-item {
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .conversation-item:hover {
            background: var(--bg-tertiary);
            transform: translateX(5px);
        }

        .conversation-item.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            transform: translateX(10px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .conversation-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .conversation-preview {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
        }

        .chat-header {
            padding: 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chat-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .chat-actions {
            display: flex;
            gap: 10px;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            animation: fadeIn 0.5s ease-out;
        }

        .message.own {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }

        .message-content {
            max-width: 70%;
        }

        .message.own .message-content {
            text-align: right;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .message.own .message-header {
            flex-direction: row-reverse;
        }

        .message-author {
            font-weight: 600;
            font-size: 14px;
        }

        .message-time {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .message-bubble {
            background: var(--bg-secondary);
            padding: 12px 16px;
            border-radius: 18px;
            border: 1px solid var(--border);
            position: relative;
        }

        .message.own .message-bubble {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
        }

        .message-text {
            line-height: 1.5;
        }

        .message-reactions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .reaction {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reaction:hover {
            transform: scale(1.1);
        }

        .message-input-container {
            padding: 20px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
        }

        .message-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message-input {
            flex: 1;
            min-height: 50px;
            max-height: 120px;
            padding: 15px;
            border: 2px solid var(--border);
            border-radius: 25px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            resize: none;
            font-family: inherit;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .message-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .send-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .send-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-out;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid var(--border);
            animation: bounce 0.6s ease-out;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.3rem;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Settings */
        .settings-section {
            margin-bottom: 30px;
        }

        .settings-section h3 {
            margin-bottom: 15px;
            color: var(--primary);
        }

        .color-themes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
        }

        .theme-option {
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--border);
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .theme-option.active {
            border-color: var(--primary);
            transform: scale(1.05);
        }

        .theme-preview {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin: 0 auto 10px;
        }

        .blocked-users {
            max-height: 200px;
            overflow-y: auto;
        }

        .blocked-user {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 10px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: -350px;
                z-index: 200;
                transition: left 0.3s ease;
            }

            .sidebar.show {
                left: 0;
            }

            .chat-container {
                width: 100%;
            }

            .app-header {
                padding: 15px 20px;
            }

            .modal-content {
                padding: 20px;
                margin: 20px;
            }
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: var(--text-secondary);
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .emoji-picker {
            position: absolute;
            bottom: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 15px;
            display: none;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .emoji-picker.show {
            display: grid;
        }

        .emoji-btn {
            padding: 8px;
            border: none;
            background: none;
            cursor: pointer;
            border-radius: 8px;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .emoji-btn:hover {
            background: var(--bg-tertiary);
            transform: scale(1.2);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            z-index: 1001;
            animation: slideIn 0.3s ease-out;
        }

        .notification.success {
            background: var(--success);
        }

        .notification.error {
            background: var(--danger);
        }

        .notification.warning {
            background: var(--warning);
        }

        /* Éviter la détection des bloqueurs de pub */
        .firebase-request {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Masquer les erreurs de connexion */
        .firebase-error {
            display: none;
        }
        /* Messages supprimés */
        .message.deleted .message-bubble {
            background: var(--bg-tertiary) !important;
            border: 1px dashed var(--border);
        }

        .deleted-message {
            background: var(--bg-tertiary) !important;
        }

        /* Profils cliquables */
        .message-author:hover {
            text-decoration: underline;
        }

        .message-avatar:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        /* Carte de profil responsive */
        @media (max-width: 768px) {
            #userProfileCard {
                max-width: 95%;
                padding: 20px;
            }
        }
        /* Messages bloqués */
        .message.blocked-message {
            opacity: 0.6;
            margin: 5px 0;
        }

        .blocked-message-bubble {
            transition: all 0.3s ease !important;
        }

        .blocked-message-bubble:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.2);
        }

        /* Animation pour les messages temporairement révélés */
        .message.blocked-message.revealed {
            animation: revealMessage 0.3s ease;
        }

        @keyframes revealMessage {
            0% {
                opacity: 0.6;
                transform: scale(0.98);
            }
            50% {
                opacity: 1;
                transform: scale(1.02);
            }
            100% {
                opacity: 0.8;
                transform: scale(1);
            }
        }
        /* Pop-up de don */
        .donation-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeInDonation 0.5s ease;
            opacity: 0;
            visibility: hidden;
        }

        .donation-popup.show {
            opacity: 1;
            visibility: visible;
        }

        .donation-content {
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            border-radius: 25px;
            max-width: 500px;
            width: 95%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary);
            position: relative;
            animation: bounceInDonation 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .donation-header {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            padding: 25px;
            border-radius: 23px 23px 0 0;
            text-align: center;
            position: relative;
        }

        .donation-header h2 {
            color: white;
            margin: 0;
            font-size: 1.4rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            animation: pulse 2s infinite;
        }

        .close-donation {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 28px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-donation:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg) scale(1.1);
        }

        .donation-body {
            padding: 30px;
            text-align: center;
        }

        .emoji-rain {
            font-size: 24px;
            margin-bottom: 20px;
            animation: rainbowGlow 3s ease-in-out infinite;
            letter-spacing: 8px;
        }

        .donation-intro {
            font-size: 1.1rem;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .app-highlight {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
            font-size: 1.2em;
        }

        .highlight {
            background: linear-gradient(135deg, var(--success), #10d9a0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.3);
        }

        .features-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 25px 0;
            text-align: left;
        }

        .feature {
            background: var(--bg-tertiary);
            padding: 12px 15px;
            border-radius: 12px;
            border-left: 4px solid var(--success);
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .feature:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.2);
        }

        .reality-check {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(245, 158, 11, 0.1));
            padding: 20px;
            border-radius: 15px;
            margin: 25px 0;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .reality-check h3 {
            color: var(--warning);
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .donation-appeal {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(240, 147, 251, 0.1));
            padding: 20px;
            border-radius: 15px;
            margin: 25px 0;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .donation-appeal h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .donation-appeal ul {
            text-align: left;
            margin: 15px 0;
        }

        .donation-appeal li {
            margin: 8px 0;
            font-size: 0.95rem;
        }

        .donation-buttons {
            margin: 30px 0 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .btn-coffee {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: white;
            text-decoration: none;
            padding: 18px 30px;
            border-radius: 50px;
            font-weight: 700;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.4);
            position: relative;
            overflow: hidden;
        }

        .btn-coffee::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn-coffee:hover::before {
            left: 100%;
        }

        .btn-coffee:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 35px rgba(255, 107, 53, 0.6);
            animation: heartbeat 1s infinite;
        }

        .btn-subtitle {
            font-size: 0.85rem;
            font-weight: 400;
            opacity: 0.9;
            margin-top: 3px;
        }

        .btn-later {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn-later:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            transform: translateY(-2px);
        }

        .donation-thanks {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(52, 211, 153, 0.1));
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(16, 185, 129, 0.2);
            font-size: 0.95rem;
            line-height: 1.5;
            margin-top: 20px;
        }

        /* Animations */
        @keyframes fadeInDonation {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes bounceInDonation {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3) rotate(-10deg);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1) rotate(5deg);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
            }
        }

        @keyframes rainbowGlow {
            0%, 100% { 
                filter: hue-rotate(0deg) brightness(1.2); 
                transform: scale(1);
            }
            50% { 
                filter: hue-rotate(180deg) brightness(1.5); 
                transform: scale(1.1);
            }
        }

        @keyframes heartbeat {
            0%, 100% { transform: translateY(-3px) scale(1.05); }
            50% { transform: translateY(-5px) scale(1.08); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .donation-content {
                width: 98%;
                max-height: 95vh;
            }
            
            .features-list {
                grid-template-columns: 1fr;
            }
            
            .donation-header h2 {
                font-size: 1.2rem;
            }
            
            .emoji-rain {
                font-size: 20px;
                letter-spacing: 4px;
            }
        }
        /* Messages image */
        .image-message {
            padding: 4px !important;
            background: transparent !important;
            border: none !important;
        }

        .message.own .image-message {
            background: transparent !important;
        }

        /* Prévisualisation d'image */
        #imagePreview img {
            transition: all 0.3s ease;
        }

        #imagePreview img:hover {
            transform: scale(1.02);
        }

        /* Modal d'image */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Bouton photo */
        .btn-secondary:hover {
            transform: scale(1.1);
        }
        /* Interface de signalement */
        @keyframes reportSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .report-reason {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .report-reason:hover {
            background: var(--bg-secondary);
            border-color: var(--primary);
            transform: translateX(5px);
        }

        .report-reason input[type="checkbox"] {
            display: none;
        }

        .report-reason input[type="checkbox"]:checked + .checkmark {
            background: var(--primary);
            color: white;
            transform: scale(1.2);
        }

        .report-reason.selected {
            background: rgba(102, 126, 234, 0.1);
            border-color: var(--primary);
        }

        .checkmark {
            width: 35px;
            height: 35px;
            border-radius: 8px;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .reason-text {
            flex: 1;
            font-weight: 500;
        }

        /* Images signalées */
        .image-reported {
            position: relative;
            filter: blur(10px);
            transition: filter 0.3s ease;
        }

        .image-heavily-reported {
            filter: blur(15px) brightness(0.5);
        }

        .report-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
        }

        .report-overlay:hover {
            background: rgba(0,0,0,0.9);
            transform: translate(-50%, -50%) scale(1.05);
        }

        .image-deleted-message {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(245, 158, 11, 0.1));
            border: 1px solid var(--danger);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            color: var(--danger);
        }

        .report-button {
            color: var(--danger);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
            opacity: 0.7;
        }

        .report-button:hover {
            opacity: 1;
            background: rgba(239, 68, 68, 0.1);
            transform: scale(1.1);
        }
        /* Améliorer tous les boutons de réaction */
        .message-reactions {
            margin-top: 8px;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .message-reactions .reaction {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .message-reactions .reaction:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-1px);
        }

        /* Bouton + spécifiquement */
        .message-reactions button:last-child {
            background: rgba(255, 255, 255, 0.9) !important;
            color: #666 !important;
            border: 1px solid rgba(200, 200, 200, 0.7) !important;
            font-weight: bold;
            min-width: 30px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message-reactions button:last-child:hover {
            background: white !important;
            color: #333 !important;
            border-color: var(--primary) !important;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
        }
        /* Positionnement relatif pour les images avec bouton signaler */
        .message-bubble.image-message {
            position: relative !important;
        }
        /* Animation pour l'interface des paramètres */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        /* Conteneur pour image avec bouton signaler */
        .image-container {
            position: relative;
            display: inline-block;
            margin-bottom: 35px; /* Espace pour le bouton en dessous */
        }

        /* Image dans le conteneur */
        .image-container img {
            display: block;
            max-width: 100%;
            height: auto;
            border-radius: 12px;
        }

        /* Bouton signaler positionné juste en bas à droite de l'image */
        .image-container .report-button {
            position: absolute;
            bottom: -30px; /* 30px en dessous de l'image */
            right: 5px;     /* 5px du bord droit */
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            user-select: none;
        }

        .image-container .report-button:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.05);
        }
        /* Boutons de danger */
        .btn-danger {
            background: var(--danger) !important;
            color: white !important;
            border: 1px solid var(--danger) !important;
            transition: all 0.3s ease;
        }

        .btn-danger:hover {
            background: #dc2626 !important;
            border-color: #dc2626 !important;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.3);
        }

        /* Interface de confirmation */
        #confirmDeleteInterface,
        #confirmLeaveInterface {
            animation: bounceIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* Badge admin dans les profils */
        .admin-badge {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-weight: 600;
            font-size: 11px;
            display: inline-block;
            margin-left: 8px;
            vertical-align: middle;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Badge dans les messages */
        .message-author.admin {
            position: relative;
        }

        .message-author.admin::after {
            content: '👑';
            margin-left: 5px;
            font-size: 12px;
            opacity: 0.8;
        }
        /* Container principal avec sidebar et chat centré */
        #appContainer {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .app-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: var(--bg-primary);
            overflow-y: auto;
            flex-shrink: 0;                /* Empêche la sidebar de rétrécir */
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: var(--bg-secondary);
            overflow: hidden;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            padding-bottom: 80px;           /* Espace pour la barre de saisie */
            box-sizing: border-box;
        }

        /* ✅ CORRECTION PRINCIPALE - Barre de saisie dans la zone chat seulement */
        .message-input-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex !important;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            box-sizing: border-box;
            z-index: 100;
        }

        .message-input-wrapper {
            display: flex;
            width: 100%;
            gap: 10px;
            align-items: center;
        }

        /* ✅ Input qui prend toute la largeur disponible */
        .message-input {
            flex: 1;
            min-width: 0;                   /* Important pour flex */
            padding: 12px 16px;
            font-size: 16px;
            border-radius: 25px;
            border: 1px solid var(--border);
            outline: none;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            resize: none;
            box-sizing: border-box;
        }

        /* ✅ Boutons avec taille fixe */
        .send-btn {
            flex-shrink: 0;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: var(--primary);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        /* Boutons emoji et photo */
        .message-input-wrapper .btn {
            flex-shrink: 0;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            min-width: 40px;                /* Force la largeur */
        }

        /* Emoji picker positionné correctement */
        .emoji-picker {
            position: absolute;
            bottom: 50px;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px;
            display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
            z-index: 200;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
        }

        .emoji-picker[style*="display: block"] {
            display: grid !important;
        }

        .emoji-btn {
            font-size: 18px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .emoji-btn:hover {
            background: var(--bg-tertiary);
        }
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        .chat-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .delete-conversation-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .delete-conversation-btn:hover {
            background: #dc2626;
        }
        .delete-conversation-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .delete-conversation-btn:hover {
            background: #dc2626;
        }
        #replyPreview {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #replyPreview:hover {
            background: var(--bg-secondary);
        }

        /* Animation du bouton annuler */
        #replyPreview button:hover {
            background: var(--bg-primary);
            border-radius: 50%;
        }

        /* Indicateur visuel de réponse dans l'input */
        #messageInput:has(+ #replyPreview[style*="block"]) {
            border-left: 3px solid var(--primary);
        }
        .close-btn {
            background: rgba(255, 255, 255, 0.92);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            outline: none;
            position: absolute;
            top: 15px;
            right: 15px;
            color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .close-btn:hover {
            background: rgba(239, 68, 68, 0.95);
            color: white;
            transform: scale(1.05);
        }

        .settings-section {
            margin-bottom: 25px;
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .settings-section h3 {
            margin: 0 0 15px 0;
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
        }

        #feedbackText:focus {
            border-color: var(--primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        #sendFeedbackBtn:disabled {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.6;
        }

        #sendFeedbackBtn:enabled {
            background: var(--primary);
            color: white;
            cursor: pointer;
        }

        #sendFeedbackBtn:enabled:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        .message-text strong {
            font-weight: 700;
            color: var(--text-primary);
        }

        .message-text em {
            font-style: italic;
            color: var(--text-primary);
        }

        .message-text u {
            text-decoration: underline;
        }

        .message-text del {
            text-decoration: line-through;
            opacity: 0.7;
        }

        .message-text code {
            background: #f1f3f4 !important;
            padding: 2px 6px !important;
            border-radius: 4px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 0.9em !important;
        }

        .message-text pre {
            background: #2d2d2d !important;
            color: #f8f8f2 !important;
            padding: 12px !important;
            border-radius: 8px !important;
            margin: 10px 0 !important;
            overflow-x: auto !important;
        }

        .message-text blockquote {
            border-left: 4px solid var(--primary) !important;
            padding-left: 16px !important;
            margin: 10px 0 !important;
            color: var(--text-secondary) !important;
            font-style: italic !important;
            background: var(--bg-tertiary) !important;
            padding: 12px !important;
            border-radius: 0 8px 8px 0 !important;
        }

        .message-text h1, .message-text h2, .message-text h3, 
        .message-text h4, .message-text h5, .message-text h6 {
            color: var(--text-primary) !important;
            margin: 12px 0 8px 0 !important;
        }

        .message-text ul, .message-text ol {
            margin: 10px 0 !important;
            padding-left: 20px !important;
        }

        .message-text li {
            margin: 4px 0 !important;
        }

        .message-text a {
            color: var(--primary) !important;
            text-decoration: underline !important;
        }

        .message-text a:hover {
            opacity: 0.8;
        }
        @keyframes menuSlideIn {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .hashtag-menu {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .hashtag-menu-item:active {
            transform: scale(0.98);
        }

        .conversation-last-message {
            color: var(--text-secondary);
            font-size: 13px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 200px; /* Ajuste selon ta largeur */
        }

        .conversation-last-message:hover {
            color: var(--text-primary);
        }

        /* Tooltip pour voir le message complet au survol */
        .conversation-item {
            position: relative;
        }

        .conversation-last-message[title]:hover::after {
            content: attr(title);
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px;
            font-size: 12px;
            color: var(--text-primary);
            z-index: 1000;
            max-width: 300px;
            word-wrap: break-word;
            left: 100%;
            top: 0;
            margin-left: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .message-text {
            line-height: 1.6;
            word-wrap: break-word;
        }

        .message-text code {
            background: var(--bg-tertiary) !important;
            color: var(--primary) !important;
            border: 1px solid var(--border) !important;
        }

        .message-text pre {
            background: var(--bg-tertiary) !important;
            border: 1px solid var(--border) !important;
        }

        .message-text blockquote {
            background: var(--bg-tertiary) !important;
            border-left: 4px solid var(--primary) !important;
        }

        .message-text h1, .message-text h2, .message-text h3, 
        .message-text h4, .message-text h5, .message-text h6 {
            color: var(--text-primary) !important;
        }

        .message-text ul, .message-text ol {
            color: var(--text-primary) !important;
        }

        .message-text strong, .message-text em, .message-text u {
            color: var(--text-primary) !important;
        }
        /* Styles pour le scroll horizontal */
        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar {
            height: 6px;
        }

        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Pour Firefox */
        .reaction-menu div[style*="overflow-x: auto"] {
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--bg-tertiary);
        }
        /* Styles pour le scroll horizontal - identique au menu hashtag */
        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar {
            height: 4px;
        }

        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar-track {
            background: transparent;
        }

        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
        /* Scroll horizontal stylé */
        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar {
            height: 4px;
        }

        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar-track {
            background: transparent;
        }

        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .reaction-menu div[style*="overflow-x: auto"]::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
        /* Styles pour les lignes de séparation dans les messages */
        .message-text hr {
            border: none !important;
            border-top: 2px solid var(--border) !important;
            margin: 16px 0 !important;
            border-radius: 1px !important;
            opacity: 0.7 !important;
            transition: opacity 0.3s ease !important;
        }

        .message-text hr:hover {
            opacity: 1 !important;
        }

        /* Version plus stylée avec dégradé */
        .message-text hr.gradient {
            background: linear-gradient(to right, transparent, var(--border), transparent) !important;
            border: none !important;
            height: 2px !important;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .image-modal {
            backdrop-filter: blur(2px);
        }

        body.modal-open {
            overflow: hidden;
        }
        .message.announcement .message-bubble {
            border: 2px solid var(--danger) !important;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%) !important;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.3) !important;
            position: relative;
        }

        .message.announcement .message-bubble::before {
            content: "📢";
            position: absolute;
            top: -10px;
            right: -10px;
            background: var(--danger);
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .message.announcement .message-author {
            color: var(--danger) !important;
            font-weight: bold !important;
        }
    </style>
</head>
<body>
    <!-- Pop-up de don -->
    <div id="donationPopup" class="donation-popup">
        <div class="donation-content">
            <div class="donation-header">
                <h2>💖 Un petit geste qui fait la différence ! 💖</h2>
                <button class="close-donation" onclick="closeDonationPopup()">&times;</button>
            </div>
            
            <div class="donation-body">
                <div class="emoji-rain">✨💫⭐🌟💝🎉🚀💎</div>
                
                <p class="donation-intro">
                    <strong>Salut ! 👋</strong> Tu utilises <span class="app-highlight">Ulyra</span>, une messagerie moderne, 
                    <span class="highlight">100% gratuite</span> et <span class="highlight">illimitée</span> ! 🎊
                </p>
                
                <div class="features-list">
                    <div class="feature">🚫 <strong>Aucune publicité</strong> gênante</div>
                    <div class="feature">💰 <strong>Aucun abonnement</strong> payant</div>
                    <div class="feature">🔓 <strong>Aucune restriction</strong> d'utilisation</div>
                    <div class="feature">🌐 <strong>Plein d'autres projets</strong> gratuits en ligne</div>
                </div>
                
                <div class="reality-check">
                    <h3>🏗️ Mais derrière les coulisses...</h3>
                    <p>
                        Les <strong>serveurs</strong> 🖥️, le <strong>stockage des données</strong> 💾, 
                        les <strong>requêtes Firebase</strong> 🔥 et tous ces <strong>projets en ligne</strong> 🌍 
                        ont un coût réel ! 💸
                    </p>
                    <p>
                        Je maintiens tout ça <strong>bénévolement</strong> pour que tu puisses en profiter 
                        <span class="highlight">gratuitement</span> ! ❤️
                    </p>
                </div>
                
                <div class="donation-appeal">
                    <h3>🙏 Ton aide = Mes projets restent vivants !</h3>
                    <p>
                        Même <strong>1€</strong> ☕ fait la différence ! Ça m'aide énormément à :
                    </p>
                    <ul>
                        <li>🔧 <strong>Maintenir</strong> les serveurs en marche</li>
                        <li>⚡ <strong>Améliorer</strong> les performances</li>
                        <li>🎨 <strong>Créer</strong> de nouveaux projets gratuits</li>
                        <li>🛡️ <strong>Garder</strong> tout sans pub ni restriction</li>
                    </ul>
                </div>
                
                <div class="donation-buttons">
                    <a href="https://www.buymeacoffee.com/noebsc" target="_blank" class="btn-coffee">
                        ☕ <strong>Buy me a coffee</strong> 💖
                        <span class="btn-subtitle">Même 1€ fait la différence !</span>
                    </a>
                    
                    <button onclick="closeDonationPopup()" class="btn-later">
                        🕒 Peut-être plus tard
                    </button>
                </div>
                
                <p class="donation-thanks">
                    <strong>Merci infiniment</strong> pour ton soutien ! 🌟<br>
                    Grâce à toi, mes projets peuvent continuer à exister ! 🚀
                </p>
            </div>
        </div>
    </div>

    <!-- Auth Container -->
    <div id="authContainer" class="auth-container">
        <div class="auth-card">
            <div class="logo">
                <h1>Ulyra</h1>
                <p>Messagerie complète et illimitée</p>
            </div>
            
            <form id="authForm">
                <div class="form-group">
                    <label for="email">Adresse e-mail</label>
                    <input type="email" id="email" class="form-control" required>
                </div>
                
                <div class="form-group">
                    <label for="password">Mot de passe</label>
                    <input type="password" id="password" class="form-control" required>
                </div>
                
                <div class="form-group" id="usernameGroup" style="display: none;">
                    <label for="username">Nom d'utilisateur</label>
                    <input type="text" id="username" class="form-control">
                </div>
                
                <button type="submit" class="btn btn-primary" id="authBtn">
                    <span id="authBtnText">Se connecter</span>
                    <div id="authSpinner" class="spinner" style="display: none;"></div>
                </button>
            </form>
            
            <div class="auth-switch">
                <p id="authSwitchText">Pas de compte ? 
                    <button type="button" id="authSwitchBtn">S'inscrire</button>
                </p>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="appContainer" class="app-container">
        <header class="app-header">
            <div class="app-title">Ulyra</div>
            <!-- Barre de recherche (à placer en haut de ton interface) -->
            <div id="searchContainer" style="
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 1000;
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 25px;
                padding: 5px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            ">
                <input type="text" id="searchInput" placeholder="🔍 Rechercher dans vos discussions..." style="
                    border: none;
                    background: transparent;
                    padding: 8px 15px;
                    width: 300px;
                    outline: none;
                    color: var(--text-primary);
                    font-size: 14px;
                ">
                <div id="searchResults" style="
                    position: absolute;
                    top: 100%;
                    left: 0;
                    right: 0;
                    background: var(--bg-secondary);
                    border: 1px solid var(--border);
                    border-radius: 12px;
                    margin-top: 5px;
                    max-height: 300px;
                    overflow-y: auto;
                    display: none;
                "></div>
            </div>

            <div class="user-info">
                <span class="user-id" id="userIdDisplay"></span>
                <button class="btn btn-secondary btn-small" onclick="openSettings()">⚙️ Paramètres</button>
                <button class="btn btn-secondary btn-small" onclick="logout()">🚪 Déconnexion</button>
            </div>
        </header>

        <div class="app-body">
            <div id="adminAnnouncementModal" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
            <div class="modal-content" style="background: var(--bg-primary); border-radius: 12px; padding: 24px; width: 90%; max-width: 500px; border: 2px solid var(--primary);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="color: var(--text-primary); margin: 0; font-size: 20px;">📢 Annonce Générale</h2>
                    <button onclick="closeAnnouncementModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 24px; cursor: pointer;">✕</button>
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; color: var(--text-primary); margin-bottom: 8px; font-weight: 500;">Expéditeur :</label>
                    <input type="text" id="announcementSender" value="Ulyra" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); font-size: 14px;">
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; color: var(--text-primary); margin-bottom: 8px; font-weight: 500;">Message d'annonce :</label>
                    <textarea id="announcementMessage" placeholder="Écrivez votre annonce ici..." style="width: 100%; height: 120px; padding: 12px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); font-size: 14px; resize: vertical; font-family: inherit;"></textarea>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; gap: 8px; color: var(--text-secondary); font-size: 12px;">
                        <span>⚠️</span>
                        <span>Cette annonce sera envoyée en MP individuel à <strong id="userCount">...</strong> utilisateurs</span>
                    </div>
                </div>
                
                <div style="display: flex; gap: 12px;">
                    <button onclick="closeAnnouncementModal()" style="flex: 1; padding: 10px; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 14px;">
                        Annuler
                    </button>
                    <button onclick="sendGeneralAnnouncement()" id="sendAnnouncementBtn" style="flex: 1; padding: 10px; background: var(--danger); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                        📢 Envoyer l'annonce
                    </button>
                </div>
            </div>
        </div>
            <aside class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    <div class="sidebar-actions">
                        <button class="btn btn-primary btn-small" onclick="openNewConversation(event)">
                            ➕ Nouvelle conversation
                        </button>

                    </div>
                </div>
                <div class="conversations-list" id="conversationsList">
                    <div class="loading">
                        <div class="spinner"></div>
                        Chargement des conversations...
                    </div>
                </div>
            </aside>

            <main class="chat-container">
                <div class="chat-header" id="chatHeader" style="display: none;">
                    <div class="chat-title" id="chatTitle">Sélectionnez une conversation</div>
                    <div class="chat-actions">
                    </div>
                </div>

                <div class="messages-container" id="messagesContainer">
                    <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                        <h3>Bienvenue sur Ulyra ! 🎉</h3>
                        <p>Créez une nouvelle conversation pour commencer à discuter.</p>
                    </div>
                </div>

                <div class="message-input-container" id="messageInputContainer" style="display: none;">
                    <div id="replyPreview" style="display: none;">
                        <div style="
                            background: var(--bg-tertiary);
                            border: 1px solid var(--border);
                            border-radius: 8px;
                            padding: 12px;
                            margin: 0 20px 10px 20px;
                            display: flex;
                            align-items: center;
                            justify-content: space-between;
                        ">
                            <div style="flex: 1; display: flex; align-items: center; gap: 10px;">
                                <div style="width: 3px; height: 30px; background: var(--primary); border-radius: 2px;"></div>
                                <div style="flex: 1;">
                                    <div style="font-size: 12px; color: var(--text-secondary); font-weight: 600;">
                                        Réponse à <span id="replyAuthor"></span>
                                    </div>
                                    <div id="replyContent" style="
                                        font-size: 13px;
                                        color: var(--text-primary);
                                        margin-top: 2px;
                                        overflow: hidden;
                                        text-overflow: ellipsis;
                                        white-space: nowrap;
                                        max-width: 300px;
                                    "></div>
                                </div>
                            </div>
                            <!-- ✅ SUPPRIMÉ onclick, sera attaché par JavaScript -->
                            <button id="cancelReplyBtn" style="
                                background: none;
                                border: none;
                                color: var(--text-secondary);
                                cursor: pointer;
                                padding: 5px;
                                border-radius: 50%;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='var(--bg-secondary)'; this.style.color='var(--text-primary)'"
                            onmouseout="this.style.background='none'; this.style.color='var(--text-secondary)'">
                                ✕
                            </button>
                        </div>
                    </div>
                    <div class="message-input-wrapper">
                        <textarea 
                            id="messageInput" 
                            class="message-input" 
                            placeholder="Tapez votre message..."
                            rows="1"
                        ></textarea>
                        <div style="position: relative;">
                            <button class="btn btn-secondary btn-small" onclick="toggleEmojiPicker()">😀</button>
                            <div class="emoji-picker" id="emojiPicker">
                                <button class="emoji-btn" onclick="addEmoji('😀')">😀</button>
                                <button class="emoji-btn" onclick="addEmoji('😂')">😂</button>
                                <button class="emoji-btn" onclick="addEmoji('❤️')">❤️</button>
                                <button class="emoji-btn" onclick="addEmoji('👍')">👍</button>
                                <button class="emoji-btn" onclick="addEmoji('👎')">👎</button>
                                <button class="emoji-btn" onclick="addEmoji('🎉')">🎉</button>
                                <button class="emoji-btn" onclick="addEmoji('😍')">😍</button>
                                <button class="emoji-btn" onclick="addEmoji('🤔')">🤔</button>
                                <button class="emoji-btn" onclick="addEmoji('😎')">😎</button>
                                <button class="emoji-btn" onclick="addEmoji('🔥')">🔥</button>
                                <button class="emoji-btn" onclick="addEmoji('💯')">💯</button>
                                <button class="emoji-btn" onclick="addEmoji('✨')">✨</button>
                            </div>
                        </div>
                        
                        <!-- NOUVEAU: Bouton pour envoyer une photo -->
                        <div style="position: relative;">
                            <button class="btn btn-secondary btn-small" onclick="selectImage()" title="Envoyer une photo">
                                📷
                            </button>
                        </div>
                        
                        <button class="send-btn" onclick="sendMessage()">➤</button>
                    </div>

                </div>
            </main>
        </div>
    </div>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Paramètres</h3>
                <button class="close-btn" onclick="closeModal('settingsModal')">&times;</button>
            </div>
            
            <div class="settings-section">
                <h3>Profil</h3>
                <div class="form-group">
                    <label>Nom d'utilisateur</label>
                    <input type="text" id="displayName" class="form-control" placeholder="Votre nom d'utilisateur">
                    <button class="btn btn-primary" onclick="updateDisplayName()" style="margin-top: 10px;">
                        💾 Mettre à jour
                    </button>
                </div>
                
                <div class="form-group">
                    <label>Votre ID unique : <span id="currentUserId" style="font-family: 'Courier New', monospace; color: var(--accent);"></span></label>
                </div>
                
                <div class="form-group">
                    <label>Email : <span id="currentUserEmail" style="font-family: 'Courier New', monospace; color: var(--text-secondary);"></span></label>
                </div>
            </div>

            <div class="settings-section">
                <h3>💬 Feedback & Recommandations</h3>
                <div class="form-group">
                    <label>Partagez vos suggestions, bugs ou améliorations</label>
                    <textarea id="feedbackText" class="form-control" 
                            style="height: 100px; resize: vertical;" 
                            placeholder="Décrivez votre suggestion, un bug rencontré, ou une amélioration souhaitée... (minimum 50 caractères)"></textarea>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                        <small id="charCount" style="color: var(--text-secondary);">0/50 caractères minimum</small>
                        <button id="sendFeedbackBtn" class="btn btn-primary" style="font-size: 12px; padding: 6px 12px;" disabled onclick="sendFeedback()">
                            📤 Envoyer le feedback
                        </button>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3>🎨 Thème de couleur</h3>
                <div class="color-themes">
                    <div class="theme-option active" onclick="changeTheme('default', this)">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #667eea, #f093fb);"></div>
                        <div>Défaut</div>
                    </div>
                    <div class="theme-option" onclick="changeTheme('ocean', this)">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #2196F3, #21CBF3);"></div>
                        <div>Océan</div>
                    </div>
                    <div class="theme-option" onclick="changeTheme('forest', this)">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #4CAF50, #8BC34A);"></div>
                        <div>Forêt</div>
                    </div>
                    <div class="theme-option" onclick="changeTheme('sunset', this)">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #FF9800, #FF5722);"></div>
                        <div>Coucher de soleil</div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <h3>🚫 Utilisateurs bloqués</h3>
                <div class="blocked-users" id="blockedUsersList">
                    <p style="color: var(--text-secondary); text-align: center;">Aucun utilisateur bloqué</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Liste des IDs administrateurs
        const ADMIN_IDS = [
            '3lwDgldVPjU5pmmCJ4UL0j6P4rH3',
        ];

        // Fonction pour vérifier si un utilisateur est admin
        function isAdmin(userId) {
            return ADMIN_IDS.includes(userId);
        }

        // Configuration Firebase - Remplacez par votre configuration
        const firebaseConfig = {
            apiKey: "AIzaSyALNQ3ouw9nvT5bGTAp3DspkJJmCNSKkR0",
            authDomain: "steel-tower.firebaseapp.com",
            databaseURL: "https://steel-tower-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "steel-tower",
            storageBucket: "steel-tower.firebasestorage.app",
            messagingSenderId: "35667780895",
            appId: "1:35667780895:web:e64829aad9f63a028f7c2a",
            measurementId: "G-VPGQJ7N4WS"
        };
        // Initialiser Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();
        const messageContentCache = {};
        let messagesData = {};
        // Variables globales
        let currentUser = null;
        let currentConversation = null;
        let isLoginMode = true;
        let unsubscribeMessages = null;
        let currentReply = null;
        let currentReplyId = null;
        let currentHashtagMenu = null;
        let currentReactionMenu = null;
        let currentLoadingConversationId = null;
        let backgroundLoadingTasks = [];
        let loadingTimeouts = [];


        // Génération d'ID utilisateur unique
        function generateUserId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 10; i++) {
                if (i % 2 === 0 && i > 0) {
                    result += chars.charAt(Math.floor(Math.random() * 26)); // Lettre
                } else {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
            }
            return result;
        }

        // Auth State Observer
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                console.log('Utilisateur connecté:', user.uid);
                
                // Vérifier les données Firestore
                const userDoc = await db.collection('users').doc(user.uid).get();
                if (userDoc.exists) {
                    currentUser = { uid: user.uid, ...userDoc.data(), isAdmin: isAdmin(user.uid) };
                }
                
                // Affichage admin
                if (isAdmin(user.uid)) {
                    console.log('🎉 Administrateur connecté !');
                } else {
                }
                
                // Mise à jour de l'affichage utilisateur
                updateUserDisplay();
                
                // Interface
                safeSetDisplay('authContainer', 'none');
                safeSetDisplay('appContainer', 'block');
                
                // Charger les conversations
                loadConversations();
                
                // Afficher l'écran d'accueil si aucune conversation sélectionnée
                if (!currentConversation) {
                    showWelcomeMessage();
                }
                
                console.log('Application initialisée pour:', currentUser.displayName || currentUser.email);
                
            } else {
                safeSetDisplay('authContainer', 'block');
                safeSetDisplay('appContainer', 'none');
                
                // Nettoyer les listeners
                if (unsubscribeConversations) {
                    unsubscribeConversations();
                }
            }
        });


        async function initializeUser() {
            try {
                // Vérifier si l'utilisateur existe déjà
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                
                if (!userDoc.exists) {
                    const userId = generateUserId();
                    
                    // Vérifier que l'ID est unique
                    const existingUser = await db.collection('users').where('userId', '==', userId).get();
                    let finalUserId = userId;
                    
                    // Si l'ID existe déjà, en générer un nouveau
                    while (!existingUser.empty) {
                        finalUserId = generateUserId();
                        const checkExisting = await db.collection('users').where('userId', '==', finalUserId).get();
                        if (checkExisting.empty) break;
                    }
                    
                    await db.collection('users').doc(currentUser.uid).set({
                        email: currentUser.email,
                        userId: finalUserId,
                        displayName: currentUser.displayName || 'Utilisateur',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        theme: 'default',
                        blockedUsers: []
                    });
                }
                
                // Récupérer les données utilisateur (après création ou si existe déjà)
                const userData = (await db.collection('users').doc(currentUser.uid).get()).data();
                document.getElementById('userIdDisplay').textContent = userData.userId;
                document.getElementById('currentUserId').textContent = userData.userId;
                document.getElementById('displayName').value = userData.displayName;
                
                // Appliquer le thème sans passer d'élément (pour l'initialisation)
                if (userData.theme) {
                    changeTheme(userData.theme);
                }
                
                loadConversations();
            } catch (error) {
                showNotification('Erreur lors de l\'initialisation : ' + error.message, 'error');
            }
        }

        // Afficher l'authentification
        function showAuth() {
            document.getElementById('authContainer').style.display = 'flex';
            document.getElementById('appContainer').style.display = 'none';
        }

        // Afficher l'application
        function showApp() {
            document.getElementById('authContainer').style.display = 'none';
            document.getElementById('appContainer').style.display = 'block';
        }

        // Basculer entre connexion et inscription
        document.getElementById('authSwitchBtn').addEventListener('click', () => {
            isLoginMode = !isLoginMode;
            
            if (isLoginMode) {
                document.getElementById('authBtnText').textContent = 'Se connecter';
                document.getElementById('authSwitchText').innerHTML = 'Pas de compte ? <button type="button" id="authSwitchBtn">S\'inscrire</button>';
                document.getElementById('usernameGroup').style.display = 'none';
            } else {
                document.getElementById('authBtnText').textContent = 'S\'inscrire';
                document.getElementById('authSwitchText').innerHTML = 'Déjà un compte ? <button type="button" id="authSwitchBtn">Se connecter</button>';
                document.getElementById('usernameGroup').style.display = 'block';
            }
            
            // Re-bind l'événement
            document.getElementById('authSwitchBtn').addEventListener('click', () => {
                document.getElementById('authSwitchBtn').click();
            });
        });

        // Gestion de l'authentification
        document.getElementById('authForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const username = document.getElementById('username').value;
            
            const authSpinner = document.getElementById('authSpinner');
            const authBtnText = document.getElementById('authBtnText');
            
            authSpinner.style.display = 'block';
            authBtnText.style.display = 'none';
            
            try {
                if (isLoginMode) {
                    // CONNEXION
                    await auth.signInWithEmailAndPassword(email, password);
                    showNotification('Connexion réussie !', 'success');
                } else {
                    // INSCRIPTION
                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    const user = userCredential.user;
                    
                    // Générer l'ID utilisateur unique
                    const userId = generateUserId();
                    
                    // Sauvegarder le profil dans Firestore AVEC le pseudo
                    await db.collection('users').doc(user.uid).set({
                        displayName: username || 'Utilisateur',
                        email: email,
                        userId: userId,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        theme: 'default'
                    });
                    
                    // Optionnel : Aussi mettre à jour le profil Firebase Auth
                    if (username) {
                        await user.updateProfile({
                            displayName: username
                        });
                    }
                    
                    showNotification('Inscription réussie ! Bienvenue ' + (username || 'Utilisateur'), 'success');
                }
            } catch (error) {
                console.error('Erreur authentification:', error);
                showNotification('Erreur : ' + error.message, 'error');
            } finally {
                authSpinner.style.display = 'none';
                authBtnText.style.display = 'block';
            }
        });


        // Déconnexion
        async function logout() {
            try {
                await auth.signOut();
                showNotification('Déconnexion réussie', 'success');
            } catch (error) {
                showNotification('Erreur lors de la déconnexion', 'error');
            }
        }

        // Charger les conversations
        let unsubscribeConversations;

        function loadConversations() {
            if (!currentUser) return;
            
            const conversationsList = document.getElementById('conversationsList');
            if (!conversationsList) return;
            
            // Désabonner l'ancien listener
            if (unsubscribeConversations) {
                unsubscribeConversations();
            }
            
            // Écouter les conversations en temps réel
            unsubscribeConversations = db.collection('conversations')
                .where('participants', 'array-contains', currentUser.uid)
                .orderBy('lastMessageTime', 'desc')
                .onSnapshot(async (snapshot) => {
                    conversationsList.innerHTML = '<div style="padding: 10px; text-align: center;">Chargement...</div>';
                    
                    if (snapshot.empty) {
                        conversationsList.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: var(--text-secondary);">
                                <p>Vous n'avez pas encore de discussions.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // ✅ Utiliser let au lieu de const
                    let conversations = [];
                    
                    // Remplir le tableau avec les données
                    for (const doc of snapshot.docs) {
                        const conversationData = doc.data();
                        conversations.push({
                            id: doc.id,
                            ...conversationData
                        });
                    }
                    
                    // ✅ Filtrer APRÈS avoir rempli le tableau
                    conversations = conversations.filter(conv => {
                        // Si c'est une discussion privée et qu'elle est marquée comme supprimée par l'utilisateur
                        if (conv.type === 'private' && conv.deletedFor && conv.deletedFor[currentUser.uid]) {
                            // La montrer seulement si il y a eu un nouveau message après la suppression
                            const deletedTime = conv.deletedFor[currentUser.uid];
                            const lastMessageTime = conv.lastMessageTime;
                            
                            return lastMessageTime && lastMessageTime.toDate() > deletedTime.toDate();
                        }
                        
                        return true;
                    });
                    
                    // ✅ Afficher les conversations avec 25 caractères
                    conversationsList.innerHTML = conversations.map(conv => {
                        // Nettoyer et tronquer le dernier message à 25 caractères
                        const cleanLastMessage = cleanAndTruncateMessage(conv.lastMessage, 25);
                        
                        return `
                            <div class="conversation-item ${currentConversation?.id === conv.id ? 'active' : ''}" 
                                data-conversation-id="${conv.id}" 
                                onclick="selectConversation('${conv.id}', ${JSON.stringify(conv).replace(/"/g, '&quot;')})">
                                <div class="conversation-info">
                                    <div class="conversation-name">${getConversationDisplayName(conv)}</div>
                                    <div class="conversation-preview" title="${conv.lastMessage || ''}">
                                        ${cleanLastMessage}
                                    </div>
                                </div>
                                <div class="conversation-time">
                                    ${conv.lastMessageTime ? formatTime(conv.lastMessageTime.toDate()) : ''}
                                </div>
                            </div>
                        `;
                    }).join('');
                }, (error) => {
                    console.error('Erreur chargement conversations:', error);
                    conversationsList.innerHTML = '<p style="color: var(--danger); text-align: center;">Erreur de chargement</p>';
                });
        }

        // ✅ Fonction helper mise à jour avec 25 par défaut
        function cleanAndTruncateMessage(text, maxLength = 25) {
            if (!text || typeof text !== 'string') return 'Aucun message';
            
            // Nettoyer le Markdown
            let cleanText = text
                // Supprimer les titres #
                .replace(/^#{1,6}\s+/gm, '')
                // Supprimer le gras **text**
                .replace(/\*\*([^*]+)\*\*/g, '$1')
                // Supprimer l'italique *text*
                .replace(/\*([^*]+)\*/g, '$1')
                // Supprimer le souligné __text__
                .replace(/__([^_]+)__/g, '$1')
                // Supprimer le barré ~~text~~
                .replace(/~~([^~]+)~~/g, '$1')
                // Supprimer les citations > 
                .replace(/^>\s+/gm, '')
                // Supprimer les listes - et *
                .replace(/^[-*]\s+/gm, '')
                // Supprimer les listes numérotées
                .replace(/^\d+\.\s+/gm, '')
                // Supprimer le code inline `code`
                .replace(/`([^`]+)`/g, '$1')
                // Supprimer les liens [text](url)
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
                // Supprimer les images ![alt](url)
                .replace(/!\[[^\]]*\]\([^)]+\)/g, '📷')
                // Supprimer les hashtags (garder juste le texte)
                .replace(/#([a-zA-Z0-9_]+)/g, '$1')
                // Supprimer les blocs de code
                .replace(/``````/g, '💻 Code')
                // Supprimer les retours à la ligne multiples
                .replace(/\n+/g, ' ')
                // Supprimer les espaces multiples
                .replace(/\s+/g, ' ')
                // Trim
                .trim();
            
            // Tronquer si trop long
            if (cleanText.length > maxLength) {
                return cleanText.substring(0, maxLength).trim() + '...';
            }
            
            return cleanText || 'Message vide';
        }


        // Créer l'élément de conversation
        function createConversationElement(id, conv) {

            const div = document.createElement('div');
            div.className = 'conversation-item';
            div.onclick = () => openConversation(id, conv, div); // ✅ CORRECTION
            div.innerHTML = `
                <div class="conversation-name">${conv.name}</div>
                <div class="conversation-preview">${conv.lastMessage || 'Aucun message'}</div>
            `;
            
            return div;
        }

        // Ouvrir une conversation
        async function openConversation(id, conv, element) {
            currentConversation = { id, ...conv };
            
            // Mettre à jour l'UI
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Ajouter la classe active seulement si l'élément existe
            if (element) {
                element.classList.add('active');
            }
            
            document.getElementById('chatHeader').style.display = 'flex';
            document.getElementById('chatTitle').textContent = conv.name;
            document.getElementById('messageInputContainer').style.display = 'block';
            
            // Charger les messages
            loadMessages(id);
        }


        // Charger les messages
        function loadMessages(conversationId) {
            // ✅ ANNULER TOUS LES CHARGEMENTS PRÉCÉDENTS
            cancelAllLoadings();
            currentLoadingConversationId = conversationId;
            
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.innerHTML = '<div class="loading"><div class="spinner"></div>Chargement des messages...</div>';
            
            // Désabonner l'ancien listener
            if (unsubscribeMessages) {
                unsubscribeMessages();
            }
            
            const displayedMessages = new Set();
            let initialLoadComplete = false;
            let lastLoadedTimestamp = null; // ✅ Suivre le timestamp du dernier message chargé
            
            // ✅ ÉTAPE 1: Charger les messages récents (sans listener temps réel)
            db.collection('conversations')
                .doc(conversationId)
                .collection('messages')
                .orderBy('timestamp', 'desc')
                .limit(20)
                .get()
                .then(async (recentSnapshot) => {
                    if (currentLoadingConversationId !== conversationId) {
                        return;
                    }
                    
                    const loading = messagesContainer.querySelector('.loading');
                    if (loading) loading.remove();
                    
                    if (!recentSnapshot.empty) {
                        const recentMessages = recentSnapshot.docs.reverse();
                        
                        for (const doc of recentMessages) {
                            if (currentLoadingConversationId !== conversationId) return;
                            
                            const messageId = doc.id;
                            const message = doc.data();
                            
                            try {
                                const messageElement = await createMessageElement(messageId, message);
                                if (messageElement && currentLoadingConversationId === conversationId) {
                                    messagesContainer.appendChild(messageElement);
                                    displayedMessages.add(messageId);
                                }
                            } catch (error) {
                                console.error('Erreur création message récent:', error);
                            }
                        }
                        
                        // ✅ Mémoriser le timestamp du dernier message
                        if (recentMessages.length > 0) {
                            lastLoadedTimestamp = recentMessages[recentMessages.length - 1].data().timestamp;
                        }
                        
                        if (currentLoadingConversationId === conversationId) {
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                            console.log('✅ Messages récents chargés');
                            initialLoadComplete = true;
                            
                            // ✅ DÉMARRER LE LISTENER POUR LES NOUVEAUX MESSAGES SEULEMENT
                            startNewMessageListener(conversationId, messagesContainer, displayedMessages, lastLoadedTimestamp);
                        }
                    } else {
                        initialLoadComplete = true;
                        // Même sans messages, démarrer le listener
                        startNewMessageListener(conversationId, messagesContainer, displayedMessages, null);
                    }
                    
                    // Charger les anciens messages en arrière-plan
                    if (currentLoadingConversationId === conversationId) {
                        const timeout = setTimeout(() => {
                            if (currentLoadingConversationId === conversationId) {
                                loadOlderMessagesInBackground(conversationId, messagesContainer, displayedMessages);
                            }
                        }, 500);
                        loadingTimeouts.push(timeout);
                    }
                    
                })
                .catch(error => {
                    if (currentLoadingConversationId === conversationId) {
                        console.error('Erreur chargement messages récents:', error);
                        messagesContainer.innerHTML = '<p style="color: var(--danger); text-align: center;">Erreur de chargement</p>';
                    }
                });
            
            // Vérifier les signalements
            const reportTimeout = setTimeout(() => {
                if (currentLoadingConversationId === conversationId) {
                    checkExistingReports();
                }
            }, 3000);
            loadingTimeouts.push(reportTimeout);
        }

        // ✅ Nouvelle fonction pour écouter SEULEMENT les nouveaux messages
        function startNewMessageListener(conversationId, messagesContainer, displayedMessages, afterTimestamp) {
            console.log('🔄 Démarrage du listener pour nouveaux messages...');
            
            // ✅ ÉCOUTER TOUS LES MESSAGES RÉCENTS, pas seulement après le timestamp
            let query = db.collection('conversations')
                .doc(conversationId)
                .collection('messages')
                .orderBy('timestamp', 'desc')
                .limit(5); // Limiter à 5 messages récents pour éviter de tout recharger
            
            // ✅ LISTENER QUI DÉTECTE LES NOUVEAUX MESSAGES (y compris les tiens)
            unsubscribeMessages = query.onSnapshot((snapshot) => {
                if (currentLoadingConversationId !== conversationId) {
                    return;
                }
                
                snapshot.docChanges().forEach(async (change) => {
                    const messageId = change.doc.id;
                    const message = change.doc.data();
                    
                    // ✅ NOUVEAU MESSAGE AJOUTÉ
                    if (change.type === 'added' && !displayedMessages.has(messageId)) {
                        if (currentLoadingConversationId !== conversationId) return;
                        
                        // ✅ NOUVEAU : Gérer les notifications de suppression
                        if (message.type === 'message_deletion_notification') {
                            console.log('📢 Notification suppression reçue:', message.deletedMessageId);
                            
                            // ✅ Mettre à jour les réponses pour tous les users
                            updateRepliesAfterDeletion(message.deletedMessageId);
                            
                            // ✅ Ne pas afficher ce message système dans le chat
                            return;
                        }
                        
                        console.log('📨 Nouveau message détecté:', messageId);
                        
                        try {
                            const messageElement = await createMessageElement(messageId, message);
                            if (messageElement && currentLoadingConversationId === conversationId) {
                                messagesContainer.appendChild(messageElement);
                                displayedMessages.add(messageId);
                                
                                // Scroll vers le bas pour les nouveaux messages
                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                
                                console.log('✅ Nouveau message ajouté à l\'affichage');
                            }
                        } catch (error) {
                            console.error('Erreur nouveau message:', error);
                        }
                    }
                    // ✅ MESSAGE MODIFIÉ
                    else if (change.type === 'modified' && displayedMessages.has(messageId)) {
                        if (currentLoadingConversationId !== conversationId) return;
                        
                        console.log('✏️ Message modifié:', messageId);
                        
                        // ✅ NOUVEAU : Si un message a été marqué comme supprimé
                        if (message.deleted === true) {
                            console.log('🗑️ Message supprimé détecté:', messageId);
                            
                            // ✅ Mettre à jour l'affichage local
                            updateMessageDisplay(messageId, message);
                            
                            // ✅ Mettre à jour toutes les réponses qui référencent ce message
                            updateRepliesAfterDeletion(messageId);
                            
                            return; // Pas besoin de recréer l'élément
                        }
                        
                        const existingElement = messagesContainer.querySelector(`[data-message-id="${messageId}"]`);
                        if (existingElement) {
                            try {
                                const updatedElement = await createMessageElement(messageId, message);
                                if (updatedElement && currentLoadingConversationId === conversationId) {
                                    updatedElement.dataset.messageId = messageId;
                                    existingElement.replaceWith(updatedElement);
                                }
                            } catch (error) {
                                console.error('Erreur mise à jour message:', error);
                            }
                        }
                    }
                    // ✅ MESSAGE SUPPRIMÉ (hard delete)
                    else if (change.type === 'removed' && displayedMessages.has(messageId)) {
                        if (currentLoadingConversationId !== conversationId) return;
                        
                        console.log('🗑️ Message supprimé (hard delete):', messageId);
                        
                        const elementToRemove = messagesContainer.querySelector(`[data-message-id="${messageId}"]`);
                        if (elementToRemove) {
                            elementToRemove.remove();
                            displayedMessages.delete(messageId);
                        }
                        
                        // ✅ Mettre à jour les réponses aussi
                        updateRepliesAfterDeletion(messageId);
                    }
                });
            }, (error) => {
                console.error('Erreur listener nouveaux messages:', error);
            });
        }


        // ✅ Fonction pour annuler tous les chargements en cours
        function cancelAllLoadings() {
            console.log('🚫 Annulation de tous les chargements en cours...');
            
            // Marquer qu'aucune conversation n'est en cours de chargement
            currentLoadingConversationId = null;
            
            // Annuler tous les timeouts
            loadingTimeouts.forEach(timeout => {
                clearTimeout(timeout);
            });
            loadingTimeouts = [];
            
            // Les promises en cours vont se terminer mais leurs résultats seront ignorés
            // grâce aux vérifications currentLoadingConversationId
            backgroundLoadingTasks = [];
            
            console.log('✅ Chargements annulés');
        }

        // ✅ Version modifiée de loadOlderMessagesInBackground
        async function loadOlderMessagesInBackground(conversationId, container, displayedMessages) {
            // ✅ VÉRIFIER AU DÉBUT
            if (currentLoadingConversationId !== conversationId) {
                console.log('🚫 Chargement anciens messages annulé');
                return;
            }
            
            console.log('🔄 Chargement des messages plus anciens en arrière-plan...');
            
            const firstMessage = Array.from(displayedMessages)[0];
            if (!firstMessage) return;
            
            try {
                const firstDoc = await db.collection('conversations')
                    .doc(conversationId)
                    .collection('messages')
                    .doc(firstMessage)
                    .get();
                
                // ✅ VÉRIFIER APRÈS CHAQUE OPÉRATION ASYNC
                if (currentLoadingConversationId !== conversationId || !firstDoc.exists) {
                    return;
                }
                
                await loadMessagesBatch(conversationId, container, displayedMessages, firstDoc.data().timestamp, 50);
                
            } catch (error) {
                console.error('Erreur chargement messages anciens:', error);
            }
        }

        // ✅ Version modifiée de loadMessagesBatch
        async function loadMessagesBatch(conversationId, container, displayedMessages, beforeTimestamp, limit) {
            // ✅ VÉRIFIER AU DÉBUT
            if (currentLoadingConversationId !== conversationId) {
                return;
            }
            
            const olderSnapshot = await db.collection('conversations')
                .doc(conversationId)
                .collection('messages')
                .orderBy('timestamp', 'desc')
                .startAfter(beforeTimestamp)
                .limit(limit)
                .get();
            
            // ✅ VÉRIFIER APRÈS L'OPÉRATION ASYNC
            if (currentLoadingConversationId !== conversationId) {
                return;
            }
            
            if (olderSnapshot.empty) {
                console.log('✅ Tous les messages historiques chargés');
                return;
            }
            
            // Sauvegarder la position de scroll
            const currentScrollTop = container.scrollTop;
            const currentScrollHeight = container.scrollHeight;
            
            const olderMessages = olderSnapshot.docs.reverse();
            
            for (let i = olderMessages.length - 1; i >= 0; i--) {
                // ✅ VÉRIFIER À CHAQUE ITÉRATION
                if (currentLoadingConversationId !== conversationId) {
                    return;
                }
                
                const doc = olderMessages[i];
                const messageId = doc.id;
                
                if (!displayedMessages.has(messageId)) {
                    try {
                        const messageElement = await createMessageElement(messageId, doc.data());
                        if (messageElement && currentLoadingConversationId === conversationId) {
                            container.insertBefore(messageElement, container.firstChild);
                            displayedMessages.add(messageId);
                        }
                    } catch (error) {
                        console.error('Erreur création message ancien:', error);
                    }
                }
            }
            
            // ✅ VÉRIFIER AVANT DE MODIFIER LE SCROLL
            if (currentLoadingConversationId === conversationId) {
                const newScrollHeight = container.scrollHeight;
                container.scrollTop = currentScrollTop + (newScrollHeight - currentScrollHeight);
                
                console.log(`✅ ${olderMessages.length} messages anciens chargés (position maintenue)`);
                
                // Continuer le chargement
                if (olderMessages.length === limit) {
                    const timeout = setTimeout(() => {
                        if (currentLoadingConversationId === conversationId) {
                            loadMessagesBatch(conversationId, container, displayedMessages, olderMessages[0].data().timestamp, limit);
                        }
                    }, 1000);
                    loadingTimeouts.push(timeout);
                }
            }
        }

        // ✅ Fonction pour charger les messages plus anciens en arrière-plan
        async function loadOlderMessagesInBackground(conversationId, container, displayedMessages) {
            console.log('🔄 Chargement des messages plus anciens en arrière-plan...');
            
            // Trouver le timestamp du message le plus ancien affiché
            const firstMessage = Array.from(displayedMessages)[0];
            if (!firstMessage) return;
            
            try {
                // Récupérer le timestamp du premier message
                const firstDoc = await db.collection('conversations')
                    .doc(conversationId)
                    .collection('messages')
                    .doc(firstMessage)
                    .get();
                
                if (!firstDoc.exists) return;
                
                // Charger les messages antérieurs par batches
                await loadMessagesBatch(conversationId, container, displayedMessages, firstDoc.data().timestamp, 50);
                
            } catch (error) {
                console.error('Erreur chargement messages anciens:', error);
            }
        }

        // ✅ Fonction pour charger par batch sans affecter la position de scroll
        async function loadMessagesBatch(conversationId, container, displayedMessages, beforeTimestamp, limit) {
            const olderSnapshot = await db.collection('conversations')
                .doc(conversationId)
                .collection('messages')
                .orderBy('timestamp', 'desc')
                .startAfter(beforeTimestamp)
                .limit(limit)
                .get();
            
            if (olderSnapshot.empty) {
                console.log('✅ Tous les messages historiques chargés');
                return;
            }
            
            // ✅ Sauvegarder la position de scroll actuelle
            const currentScrollTop = container.scrollTop;
            const currentScrollHeight = container.scrollHeight;
            
            // Ajouter les messages plus anciens AU DÉBUT du container
            const olderMessages = olderSnapshot.docs.reverse(); // Du plus ancien au plus récent
            
            for (let i = olderMessages.length - 1; i >= 0; i--) {
                const doc = olderMessages[i];
                const messageId = doc.id;
                
                if (!displayedMessages.has(messageId)) {
                    try {
                        const messageElement = await createMessageElement(messageId, doc.data());
                        if (messageElement) {
                            // Insérer au début
                            container.insertBefore(messageElement, container.firstChild);
                            displayedMessages.add(messageId);
                        }
                    } catch (error) {
                        console.error('Erreur création message ancien:', error);
                    }
                }
            }
            
            // ✅ Restaurer la position de scroll (l'utilisateur ne bouge pas)
            const newScrollHeight = container.scrollHeight;
            container.scrollTop = currentScrollTop + (newScrollHeight - currentScrollHeight);
            
            console.log(`✅ ${olderMessages.length} messages anciens chargés (position maintenue)`);
            
            // Continuer à charger s'il y a encore des messages
            if (olderMessages.length === limit) {
                setTimeout(() => {
                    loadMessagesBatch(conversationId, container, displayedMessages, olderMessages[0].data().timestamp, limit);
                }, 1000);
            }
        }


        // Créer l'élément de message
        async function createMessageElement(messageId, message) {
            const div = document.createElement('div');
            div.dataset.messageId = messageId;
            console.log('🔍 createMessageElement appelée avec:', { messageId, messageType: message.type });

            if (!messageId) {
                console.error('❌ messageId invalide dans createMessageElement');
                return null;
            }

            // ----- USER BLOCK CHECK & SENDER INFO -----
            const isBlocked = message.senderId !== 'system' && message.senderId !== currentUser.uid ? 
                await isUserBlocked(message.senderId) : false;

            // ✅ NOUVEAU : Ajouter classe pour les annonces
            div.className = `message ${message.senderId === currentUser.uid ? 'own' : ''} ${message.deleted ? 'deleted' : ''} ${isBlocked ? 'blocked-message' : ''} ${message.isGeneralAnnouncement || message.type === 'announcement' ? 'announcement' : ''}`;

            let senderName = 'Utilisateur bloqué';
            let senderInitials = 'B';
            if (message.senderId === 'system') {
                senderName = 'Système';
                senderInitials = 'S';
            } else if (message.senderDisplayName && (message.isGeneralAnnouncement || message.type === 'announcement')) {
                // ✅ NOUVEAU : Utiliser le nom personnalisé pour les annonces
                senderName = message.senderDisplayName;
                senderInitials = senderName.charAt(0).toUpperCase();
            } else if (!isBlocked || message.senderId === currentUser.uid) {
                try {
                    const senderDoc = await db.collection('users').doc(message.senderId).get();
                    if (senderDoc.exists) {
                        const senderData = senderDoc.data();
                        senderName = senderData.displayName || 'Utilisateur inconnu';
                        senderInitials = senderName.charAt(0).toUpperCase();
                    }
                } catch (error) {
                    senderName = 'Utilisateur inconnu';
                    senderInitials = 'U';
                }
            }

            const timestamp = message.timestamp ? message.timestamp.toDate().toLocaleTimeString() : 'Maintenant';
            const isOwnMessage = message.senderId === currentUser.uid;
            const isSystemMessage = message.senderId === 'system';
            const isAnnouncement = message.isGeneralAnnouncement || message.type === 'announcement';

            // ----- BLOCKED MESSAGE -----
            if (isBlocked && !isOwnMessage && !isAnnouncement) { // ✅ Les annonces ne sont jamais bloquées
                div.innerHTML = `
                    <div class="message-avatar" style="background: #666; cursor: default;">
                        ${senderInitials}
                    </div>
                    <div class="message-content">
                        <div class="message-header">
                            <span class="message-author ${isAdmin(message.senderId) ? 'admin' : ''}" 
                                ${!isSystemMessage ? `onclick="showUserProfile('${message.senderId}')"` : ''}
                                style="cursor: ${!isSystemMessage ? 'pointer' : 'default'}; ${!isSystemMessage ? 'color: var(--primary);' : ''}">
                                ${senderName}
                            </span>
                            <span class="message-time" style="opacity: 0.5;">${timestamp}</span>
                        </div>
                        <div class="message-bubble blocked-message-bubble" 
                            onclick="revealBlockedMessage(this)"
                            style="background: rgba(0,0,0,0.1) !important; border: 1px dashed #666; cursor: pointer; transition: all 0.3s ease;"
                            onmouseover="this.style.background='rgba(239, 68, 68, 0.1)'"
                            onmouseout="this.style.background='rgba(0,0,0,0.1)'">
                            <div class="message-text" style="font-style: italic; opacity: 0.4; color: #666;">
                                Message masqué (utilisateur bloqué) - Cliquez pour afficher
                            </div>
                        </div>
                    </div>
                `;
                const bubble = div.querySelector('.message-bubble');
                bubble.dataset.originalText = message.text || message.type === 'image' ? '📷 Photo' : 'Contenu masqué';
                return div;
            }

            // ----- PREPARE REPLY BUBBLE -----
            let replyHTML = '';
            if (message.replyTo && message.replyTo.messageId) {
                let originalText = '';
                let isOriginalDeleted = false;
                
                // ✅ Vérifier si le message original est supprimé AVANT affichage
                try {
                    // Vérifier dans le cache window.messagesCache s'il existe
                    if (window.messagesCache && window.messagesCache[message.replyTo.messageId]) {
                        const cachedMessage = window.messagesCache[message.replyTo.messageId];
                        isOriginalDeleted = cachedMessage.deleted === true;
                        originalText = isOriginalDeleted ? '' : (cachedMessage.text || '(contenu non disponible)');
                    } 
                    // ✅ Si pas en cache, vérifier dans le DOM (message peut être affiché comme supprimé)
                    else {
                        const existingMessage = document.querySelector(`[data-message-id="${message.replyTo.messageId}"]`);
                        if (existingMessage && existingMessage.classList.contains('deleted')) {
                            isOriginalDeleted = true;
                            originalText = '';
                        }
                        // Sinon utiliser les données stockées dans replyTo
                        else if (typeof message.replyTo.text === 'string' && message.replyTo.text.trim()) {
                            originalText = message.replyTo.text.trim();
                        } else if (typeof message.replyTo.content === 'string' && message.replyTo.content.trim()) {
                            originalText = message.replyTo.content.trim();
                        } else {
                            originalText = '(chargement...)';
                        }
                    }
                } catch (error) {
                    console.warn('Erreur vérification message original:', error);
                    originalText = '(chargement...)';
                }

                // ✅ Texte à afficher selon l'état
                let displayText;
                let replyStyle = '';
                let clickAction = '';
                let borderColor = 'var(--primary)';
                let headerColor = 'var(--primary)';
                
                if (isOriginalDeleted) {
                    displayText = '🗑️ Le message original a été supprimé';
                    replyStyle = 'font-style: italic; opacity: 0.6; color: var(--text-secondary);';
                    clickAction = ''; // Pas de clic possible
                    borderColor = 'var(--text-secondary)';
                    headerColor = 'var(--text-secondary)';
                } else {
                    displayText = originalText;
                    clickAction = `onclick="scrollToMessage('${message.replyTo.messageId}')"`;
                }

                replyHTML = `
                    <div class="reply-bubble" id="reply-bubble-${messageId}"
                        ${clickAction}
                        style="cursor: ${isOriginalDeleted ? 'default' : 'pointer'}; transition: all 0.3s ease; background: var(--bg-tertiary); border-left: 3px solid ${borderColor}; margin-bottom: 8px; padding: 8px 12px; border-radius: 8px; font-size: 13px; opacity: 0.8;"
                        ${!isOriginalDeleted ? `onmouseover="this.style.background='var(--bg-secondary)'" onmouseout="this.style.background='var(--bg-tertiary)'"` : ''}>
                        <div style="color: ${headerColor}; font-weight: 600; font-size: 11px; margin-bottom: 2px;">
                            ↳ Réponse à ${message.replyTo.author || 'Utilisateur'}
                        </div>
                        <div class="reply-content" style="color: var(--text-secondary); line-height: 1.3; ${replyStyle}">
                            ${displayText}
                        </div>
                    </div>
                `;

                // ✅ Vérification asynchrone seulement si nécessaire
                if (originalText === '(chargement...)' && !isOriginalDeleted) {
                    setTimeout(async () => {
                        try {
                            const ref = db.collection('conversations')
                                .doc(currentConversation.id)
                                .collection('messages')
                                .doc(message.replyTo.messageId);
                            const doc = await ref.get();
                            
                            if (doc.exists) {
                                const data = doc.data();
                                const replyBubble = document.getElementById('reply-bubble-' + messageId);
                                if (replyBubble) {
                                    const replyContent = replyBubble.querySelector('.reply-content');
                                    if (replyContent) {
                                        if (data.deleted === true) {
                                            // ✅ Message supprimé découvert après coup
                                            replyContent.innerHTML = '🗑️ Le message original a été supprimé';
                                            replyContent.style.fontStyle = 'italic';
                                            replyContent.style.opacity = '0.6';
                                            replyBubble.style.cursor = 'default';
                                            replyBubble.style.borderLeftColor = 'var(--text-secondary)';
                                            replyBubble.onclick = null;
                                        } else {
                                            // ✅ Message normal
                                            replyContent.textContent = data.text || '(contenu vide)';
                                        }
                                    }
                                }
                            }
                        } catch(e) { 
                            console.warn('Erreur chargement message original:', e);
                        }
                    }, 50);
                }
            }

            // ----- MESSAGE IMAGE -----
            if (message.type === 'image' && message.imageUrl) {
                div.innerHTML = `
                    <div class="message-avatar" ${!isSystemMessage && !isAnnouncement ? `onclick="showUserProfile('${message.senderId}')"` : ''} 
                        style="cursor: ${!isSystemMessage && !isAnnouncement ? 'pointer' : 'default'};">
                        ${senderInitials}
                    </div>
                    <div class="message-content">
                        <div class="message-header">
                            <span class="message-author ${isAnnouncement ? 'announcement-author' : (isAdmin(message.senderId) ? 'admin' : '')}" 
                                ${!isSystemMessage && !isAnnouncement ? `onclick="showUserProfile('${message.senderId}')"` : ''}
                                style="cursor: ${!isSystemMessage && !isAnnouncement ? 'pointer' : 'default'}; color: ${isAnnouncement ? 'var(--danger)' : (!isSystemMessage ? 'var(--primary)' : 'inherit')}; ${isAnnouncement ? 'font-weight: bold;' : ''}">
                                ${senderName}
                            </span>
                            <span class="message-time">${timestamp}</span>
                            <div class="message-actions" style="display: flex; gap: 5px; margin-left: 10px;">
                                ${!isSystemMessage && !isAnnouncement ? `
                                    <button onclick="replyToMessage('${messageId}', '📷 Photo', '${senderName}')" 
                                            style="background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.3s ease;"
                                            onmouseover="this.style.background='var(--primary)'; this.style.color='white';"
                                            onmouseout="this.style.background='none'; this.style.color='var(--text-secondary)';"
                                            title="Répondre au message">
                                        ↳
                                    </button>
                                ` : ''}
                                ${isOwnMessage && !message.deleted && !isAnnouncement ? `
                                    <button onclick="deleteMessage('${messageId}', '📷 Photo')" 
                                            style="background: none; border: none; color: var(--danger); cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.3s ease;"
                                            onmouseover="this.style.background='var(--danger)'; this.style.color='white';"
                                            onmouseout="this.style.background='none'; this.style.color='var(--danger)';"
                                            title="Supprimer le message">
                                        🗑️
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                        ${replyHTML}
                        <div class="message-bubble" style="padding: 4px; background: transparent; border: none;">
                            <div class="image-container">
                                <img src="${message.imageUrl}" 
                                    onclick="openImageModal('${message.imageUrl}', '${message.imageName || 'Image'}')"
                                    style="cursor: pointer; transition: all 0.3s ease;"
                                    onmouseover="this.style.transform='scale(1.02)'"
                                    onmouseout="this.style.transform='scale(1)'">
                                ${!isOwnMessage && !isAnnouncement ? `
                                    <button class="report-button" 
                                            onclick="showReportInterface('${messageId}', '${message.imageName || 'Image'}')"
                                            title="Signaler cette image">
                                        Signaler
                                    </button>
                                ` : ''}
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary); margin-top: 10px; text-align: center; background: var(--bg-tertiary); padding: 4px 8px; border-radius: 8px;">
                                📷 ${message.imageName || 'Image'} 
                                ${message.imageSize ? `(${(message.imageSize / 1024).toFixed(1)} KB)` : ''}
                            </div>
                            ${message.text ? '<div class="message-text" style="margin-top: 8px;"></div>' : ''}
                        </div>
                        ${!message.deleted && !isSystemMessage && !isAnnouncement ? `
                            <div class="message-reactions">
                                ${Object.entries(message.reactions || {}).map(([emoji, users]) => 
                                    `<span class="reaction" onclick="toggleReaction('${messageId}', '${emoji}')">${emoji} ${users.length}</span>`
                                ).join('')}
                                <button class="reaction" onclick="showReactionPicker('${messageId}', event)" 
                                        style="background: none; border: 1px solid var(--border); padding: 4px 8px; border-radius: 6px; cursor: pointer;">
                                    +
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
                
                // ✅ APPLIQUER MARKDOWN aux images si texte présent
                if (message.text) {
                    const messageTextElement = div.querySelector('.message-text');
                    if (messageTextElement) {
                        console.log('🔍 Application Markdown sur image avec texte:', message.text.substring(0, 50) + '...');
                        const htmlResult = parseMarkdown(message.text);
                        messageTextElement.innerHTML = htmlResult;
                    }
                }
                
                return div;
            }

            // ----- MESSAGE TEXTE NORMAL -----
            div.innerHTML = `
                <div class="message-avatar" ${!isSystemMessage && !isAnnouncement ? `onclick="showUserProfile('${message.senderId}')"` : ''} 
                    style="cursor: ${!isSystemMessage && !isAnnouncement ? 'pointer' : 'default'};">
                    ${senderInitials}
                </div>
                <div class="message-content">
                    <div class="message-header">
                        <span class="message-author ${isAnnouncement ? 'announcement-author' : (isAdmin(message.senderId) ? 'admin' : '')}" 
                            ${!isSystemMessage && !isAnnouncement ? `onclick="showUserProfile('${message.senderId}')"` : ''}
                            style="cursor: ${!isSystemMessage && !isAnnouncement ? 'pointer' : 'default'}; color: ${isAnnouncement ? 'var(--danger)' : (!isSystemMessage ? 'var(--primary)' : 'inherit')}; ${isAnnouncement ? 'font-weight: bold;' : ''}">
                            ${senderName}
                        </span>
                        <span class="message-time">${timestamp}</span>
                        <div class="message-actions" style="display: flex; gap: 5px; margin-left: 10px;">
                            ${!isSystemMessage && !message.deleted && !isAnnouncement ? `
                                <button onclick="replyToMessage('${messageId}', '${(message.text || '').replace(/'/g, "\\'")}', '${senderName}')" 
                                        style="background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.3s ease;"
                                        onmouseover="this.style.background='var(--primary)'; this.style.color='white';"
                                        onmouseout="this.style.background='none'; this.style.color='var(--text-secondary)';"
                                        title="Répondre au message">
                                    ↳
                                </button>
                            ` : ''}
                            ${isOwnMessage && !message.deleted && message.text && !isAnnouncement ? `
                                <button data-message-id="${messageId}" 
                                        data-message-text="${(message.text || '').replace(/"/g, '&quot;')}"
                                        onclick="editMessageFromButton(this)" 
                                        style="background: none; border: none; color: var(--warning); cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.3s ease;"
                                        onmouseover="this.style.background='var(--warning)'; this.style.color='white';"
                                        onmouseout="this.style.background='none'; this.style.color='var(--warning)';"
                                        title="Modifier le message">
                                    ✏️
                                </button>
                            ` : ''}
                            ${isOwnMessage && !message.deleted && !isAnnouncement ? `
                                <button data-message-id="${messageId}" 
                                        data-message-preview="${(message.text || '📷 Photo').substring(0, 50)}"
                                        onclick="deleteMessageFromButton(this, event)" 
                                        style="background: none; border: none; color: var(--danger); cursor: pointer; padding: 2px 6px; border-radius: 4px; font-size: 12px; transition: all 0.3s ease;"
                                        onmouseover="this.style.background='var(--danger)'; this.style.color='white';"
                                        onmouseout="this.style.background='none'; this.style.color='var(--danger)';"
                                        title="Supprimer le message">
                                    🗑️
                                </button>
                            ` : ''}
                        </div>
                    </div>
                    ${replyHTML}
                    <div class="message-bubble ${message.deleted ? 'deleted-message' : ''}">
                        <div class="message-text" style="${message.deleted ? 'font-style: italic; opacity: 0.7; color: var(--text-secondary);' : ''}">
                            ${message.deleted ? '🗑️ Ce message a été supprimé' : (message.text || 'Message vide')}
                        </div>
                        ${message.edited && !message.deleted ? `
                            <div class="edited-indicator" style="
                                font-size: 10px; 
                                color: var(--text-secondary); 
                                opacity: 0.6; 
                                margin-top: 6px; 
                                font-style: italic;
                                text-align: right;
                                padding: 2px 4px;
                                background: var(--bg-tertiary);
                                border-radius: 4px;
                                display: inline-block;
                                float: right;
                                clear: both;
                            ">
                                ✏️ modifié ${message.editedAt ? 'le ' + message.editedAt.toDate().toLocaleString() : ''}
                            </div>
                        ` : ''}
                    </div>
                    ${!message.deleted && !isSystemMessage && !isAnnouncement ? `
                        <div class="message-reactions">
                            ${Object.entries(message.reactions || {}).map(([emoji, users]) => 
                                `<span class="reaction" onclick="toggleReaction('${messageId}', '${emoji}')">${emoji} ${users.length}</span>`
                            ).join('')}
                            <button class="reaction" onclick="showReactionPicker('${messageId}')" style="background: none; border: 1px solid var(--border);">+</button>
                        </div>
                    ` : ''}
                </div>
            `;

            // ✅ APPLIQUER MARKDOWN AU TEXTE (seulement si pas supprimé et pas annonce système)
            if (message.text && !message.deleted && message.type !== 'system_feedback') {
                const messageTextElement = div.querySelector('.message-text');
                if (messageTextElement) {
                    console.log('🔍 Texte original:', message.text);
                    const parsedHTML = parseMarkdown(message.text);
                    console.log('🔍 HTML généré par parseMarkdown:', parsedHTML);
                    
                    messageTextElement.innerHTML = parsedHTML;
                    
                    console.log('🔍 innerHTML après injection:', messageTextElement.innerHTML);
                    console.log('🔍 textContent après injection:', messageTextElement.textContent);
                }
            }
            // ✅ AJOUTER BOUTONS ADMIN POUR FEEDBACKS
            if (message.type === 'system_feedback' && isAdmin(currentUser.uid)) {
                setTimeout(() => {
                    addFeedbackActions(message, div);
                }, 100);
            }
            return div;
        }



        // Envoyer un message
        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const messageText = messageInput.value.trim();
            
            console.log('📤 DÉBUT sendMessage');
            console.log('📤 currentReplyId:', currentReplyId);
            
            if (!messageText || !currentConversation) {
                console.log('❌ Pas de texte ou pas de conversation');
                return;
            }
            
            try {
                const batch = db.batch();
                const timestamp = firebase.firestore.FieldValue.serverTimestamp();
                
                const messageRef = db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .doc();
                
                const conversationRef = db.collection('conversations').doc(currentConversation.id);
                
                // ✅ Préparer les données du message
                const messageData = {
                    text: messageText,
                    senderId: currentUser.uid,
                    timestamp: timestamp,
                    type: 'text'
                };
                
                // ✅ NOUVEAU : Structure de réponse compatible avec displayMessage
                if (currentReplyId) {
                    try {
                        // ✅ Récupérer les infos du message original
                        const originalMessageDoc = await db.collection('conversations')
                            .doc(currentConversation.id)
                            .collection('messages')
                            .doc(currentReplyId)
                            .get();
                        
                        if (originalMessageDoc.exists) {
                            const originalData = originalMessageDoc.data();
                            
                            // ✅ Récupérer le nom de l'auteur original
                            let originalAuthor = 'Utilisateur';
                            if (originalData.senderId === currentUser.uid) {
                                originalAuthor = 'Vous';
                            } else if (originalData.senderId) {
                                try {
                                    const userDoc = await db.collection('users').doc(originalData.senderId).get();
                                    if (userDoc.exists) {
                                        const userData = userDoc.data();
                                        originalAuthor = userData.displayName || userData.name || userData.email?.split('@')[0] || 'Utilisateur';
                                    }
                                } catch (userError) {
                                    console.warn('⚠️ Impossible de récupérer l\'auteur:', userError);
                                }
                            }
                            
                            // ✅ Structure compatible avec displayMessage
                            messageData.replyTo = {
                                messageId: currentReplyId,
                                author: originalAuthor,
                                content: originalData.text || 'Message'
                            };
                            
                            messageData.replyType = 'reply';
                            
                            console.log('✅ Données de réponse ajoutées:', messageData.replyTo);
                        } else {
                            console.warn('⚠️ Message original introuvable, envoi sans réponse');
                        }
                    } catch (replyError) {
                        console.error('❌ Erreur récupération message original:', replyError);
                        // Fallback : structure minimale
                        messageData.replyTo = {
                            messageId: currentReplyId,
                            author: 'Utilisateur',
                            content: 'Message'
                        };
                    }
                }
                
                console.log('📄 Données complètes du message:', messageData);
                
                batch.set(messageRef, messageData);
                
                batch.update(conversationRef, {
                    lastMessage: messageText,
                    lastMessageTime: timestamp,
                    updatedAt: timestamp
                });
                
                await batch.commit();
                
                // ✅ Nettoyer après envoi réussi
                clearReplyMode();
                resetMessageInputHeight();
                
                console.log('✅ Message envoyé avec succès');
                
            } catch (error) {
                console.error('❌ Erreur lors de l\'envoi:', error);
                showNotification('Erreur lors de l\'envoi du message', 'error');
            }
        }

        // Gestion de la taille du textarea
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        }

        document.getElementById('messageInput').addEventListener('input', function() {
            autoResize(this);
        });

        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

    

        // Fermer le menu déroulant
        function closeNewConversationMenu(event) {
            const menu = document.getElementById('newConversationMenu');
            if (menu && !menu.contains(event.target)) {
                menu.remove();
                document.removeEventListener('click', closeNewConversationMenu);
            }
        }


        // Gestion du formulaire nouvelle conversation
        document.getElementById('newConversationForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const name = document.getElementById('conversationName').value.trim() || 'Nouvelle conversation';
            const participantsText = document.getElementById('participants').value.trim();
            const isGroup = document.getElementById('isGroup').checked;
            
            if (!participantsText) {
                showNotification('Ajoutez au moins un participant', 'warning');
                return;
            }
            
            const participantsList = participantsText.split(',').map(p => p.trim()).filter(p => p.length > 0);
            const participants = [currentUser.uid];
            
            try {
                // Résoudre les participants
                for (const participant of participantsList) {
                    try {
                        if (participant.includes('@')) {
                            // Recherche par email
                            const users = await db.collection('users').where('email', '==', participant).get();
                            if (!users.empty) {
                                const userId = users.docs[0].id;
                                if (!participants.includes(userId)) {
                                    participants.push(userId);
                                }
                            } else {
                                console.warn(`Utilisateur non trouvé pour l'email: ${participant}`);
                            }
                        } else {
                            // Recherche par ID utilisateur
                            const users = await db.collection('users').where('userId', '==', participant.toUpperCase()).get();
                            if (!users.empty) {
                                const userId = users.docs[0].id;
                                if (!participants.includes(userId)) {
                                    participants.push(userId);
                                }
                            } else {
                                console.warn(`Utilisateur non trouvé pour l'ID: ${participant}`);
                            }
                        }
                    } catch (error) {
                        console.error(`Erreur lors de la recherche du participant ${participant}:`, error);
                    }
                }
                
                if (participants.length === 1) {
                    showNotification('Aucun participant valide trouvé', 'error');
                    return;
                }
                
                if (isGroup && participants.length > 21) {
                    showNotification('Maximum 20 participants dans un groupe', 'error');
                    return;
                }
                
                // Créer la conversation avec des valeurs garanties non-undefined
                const conversationData = {
                    name: name,
                    participants: participants,
                    isGroup: isGroup,
                    createdBy: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: '',
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Vérifier qu'aucune valeur n'est undefined
                Object.keys(conversationData).forEach(key => {
                    if (conversationData[key] === undefined) {
                        console.error(`Valeur undefined détectée pour la clé: ${key}`);
                        delete conversationData[key];
                    }
                });
                
                await db.collection('conversations').add(conversationData);
                
                showNotification('Conversation créée avec succès !', 'success');
                closeModal('newConversationModal');
                loadConversations();
                
                // Reset form
                document.getElementById('newConversationForm').reset();
            } catch (error) {
                console.error('Erreur détaillée:', error);
                showNotification('Erreur lors de la création : ' + error.message, 'error');
            }
        });


        function openSettings() {
            document.getElementById('settingsModal').classList.add('show');
            loadBlockedUsers();
            
            // Remplir automatiquement les données utilisateur
            setTimeout(() => {
                fillUserSettings();
            }, 100);
        }

        // ✅ Fonction pour remplir les données utilisateur
        async function fillUserSettings() {
            if (!currentUser) return;
            
            try {
                // Récupérer les données utilisateur depuis Firestore
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    
                    // Remplir le petit ID unique (celui dans le champ userId)
                    const userIdElement = document.getElementById('currentUserId');
                    if (userIdElement) {
                        userIdElement.textContent = userData.userId || 'ID non défini';
                    }
                    
                    // Remplir l'email utilisateur
                    const userEmailElement = document.getElementById('currentUserEmail');
                    if (userEmailElement) {
                        userEmailElement.textContent = currentUser.email || 'Email non disponible';
                    }
                    
                    // Pré-remplir le nom d'utilisateur dans le champ de saisie
                    const displayNameInput = document.getElementById('displayName');
                    if (displayNameInput) {
                        displayNameInput.value = userData.displayName || currentUser.displayName || '';
                        displayNameInput.placeholder = userData.displayName || currentUser.displayName || 'Votre nom d\'utilisateur';
                    }
                    
                    console.log('✅ Paramètres utilisateur chargés:', {
                        userId: userData.userId,
                        displayName: userData.displayName,
                        email: currentUser.email
                    });
                    
                } else {
                    console.error('❌ Document utilisateur introuvable');
                    const userIdElement = document.getElementById('currentUserId');
                    if (userIdElement) {
                        userIdElement.textContent = 'Document utilisateur non trouvé';
                    }
                }
                
            } catch (error) {
                console.error('Erreur récupération données utilisateur:', error);
                
                // Fallback en cas d'erreur
                const userIdElement = document.getElementById('currentUserId');
                if (userIdElement) {
                    userIdElement.textContent = 'Erreur de chargement';
                }
            }
            
            // Initialiser le compteur de caractères du feedback
            initializeFeedbackCounter();
        }

        // Gestion du compteur de caractères pour le feedback
        document.addEventListener('DOMContentLoaded', function() {
            const feedbackTextarea = document.getElementById('feedbackText');
            const charCount = document.getElementById('charCount');
            const sendBtn = document.getElementById('sendFeedbackBtn');
            
            if (feedbackTextarea && charCount && sendBtn) {
                feedbackTextarea.oninput = function() {
                    const length = this.value.length;
                    charCount.textContent = `${length}/50 caractères minimum`;
                    
                    if (length >= 50) {
                        charCount.style.color = 'var(--success)';
                        sendBtn.disabled = false;
                        sendBtn.style.background = 'var(--primary)';
                        sendBtn.style.color = 'white';
                        sendBtn.style.cursor = 'pointer';
                    } else {
                        charCount.style.color = 'var(--text-secondary)';
                        sendBtn.disabled = true;
                        sendBtn.style.background = 'var(--bg-secondary)';
                        sendBtn.style.color = 'var(--text-secondary)';
                        sendBtn.style.cursor = 'not-allowed';
                    }
                };
            }
        });
        // Mettre à jour le nom d'affichage
        async function updateDisplayName() {
            const displayName = document.getElementById('displayName').value.trim();
            
            if (!displayName) {
                showNotification('Le nom d\'utilisateur ne peut pas être vide', 'warning');
                return;
            }
            
            try {
                await db.collection('users').doc(currentUser.uid).update({
                    displayName: displayName
                });
                
                showNotification('Nom d\'utilisateur mis à jour !', 'success');
            } catch (error) {
                showNotification('Erreur lors de la mise à jour', 'error');
            }
        }

        // Changer le thème
       function changeTheme(theme, element) {
            const themes = {
                default: {
                    primary: '#667eea',
                    secondary: '#764ba2',
                    accent: '#f093fb'
                },
                ocean: {
                    primary: '#2196F3',
                    secondary: '#21CBF3',
                    accent: '#03DAC6'
                },
                forest: {
                    primary: '#4CAF50',
                    secondary: '#8BC34A',
                    accent: '#CDDC39'
                },
                sunset: {
                    primary: '#FF9800',
                    secondary: '#FF5722',
                    accent: '#FFC107'
                }
            };
            
            const selectedTheme = themes[theme];
            if (selectedTheme) {
                const root = document.documentElement;
                root.style.setProperty('--primary', selectedTheme.primary);
                root.style.setProperty('--secondary', selectedTheme.secondary);
                root.style.setProperty('--accent', selectedTheme.accent);
                
                // Mettre à jour dans la base de données
                if (currentUser) {
                    db.collection('users').doc(currentUser.uid).update({ theme: theme });
                }
                
                // Mettre à jour l'UI seulement si on a un élément ou si on peut le trouver
                document.querySelectorAll('.theme-option').forEach(option => {
                    option.classList.remove('active');
                });
                
                if (element) {
                    // Si l'élément est passé directement
                    element.classList.add('active');
                } else {
                    // Sinon, chercher l'élément correspondant au thème (pour l'initialisation)
                    const themeElement = document.querySelector(`[onclick*="changeTheme('${theme}')"]`);
                    if (themeElement) {
                        themeElement.classList.add('active');
                    }
                }
            }
        }

        // Charger les utilisateurs bloqués
        async function loadBlockedUsers() {
            const blockedUsersList = document.getElementById('blockedUsersList');
            
            try {
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const blockedUsers = userDoc.data().blockedUsers || [];
                
                if (blockedUsers.length === 0) {
                    blockedUsersList.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Aucun utilisateur bloqué</p>';
                    return;
                }
                
                blockedUsersList.innerHTML = '';
                
                for (const blockedUserId of blockedUsers) {
                    const blockedUserDoc = await db.collection('users').doc(blockedUserId).get();
                    if (blockedUserDoc.exists) {
                        const userData = blockedUserDoc.data();
                        const div = document.createElement('div');
                        div.className = 'blocked-user';
                        div.innerHTML = `
                            <span>${userData.displayName} (${userData.userId})</span>
                            <button class="btn btn-secondary btn-small" onclick="unblockUser('${blockedUserId}')">
                                Débloquer
                            </button>
                        `;
                        blockedUsersList.appendChild(div);
                    }
                }
            } catch (error) {
                blockedUsersList.innerHTML = '<p style="color: var(--danger); text-align: center;">Erreur de chargement</p>';
            }
        }

        // Débloquer un utilisateur
        async function unblockUser(userId) {
            try {
                await db.collection('users').doc(currentUser.uid).update({
                    blockedUsers: firebase.firestore.FieldValue.arrayRemove(userId)
                });
                
                showNotification('Utilisateur débloqué', 'success');
                loadBlockedUsers();
            } catch (error) {
                showNotification('Erreur lors du déblocage', 'error');
            }
        }

        // Gestion des émojis
        function toggleEmojiPicker() {
            const picker = document.getElementById('emojiPicker');
            picker.classList.toggle('show');
        }

        function addEmoji(emoji) {
            const messageInput = document.getElementById('messageInput');
            messageInput.value += emoji;
            messageInput.focus();
            document.getElementById('emojiPicker').classList.remove('show');
        }

        // Réactions aux messages
        async function toggleReaction(messageId, emoji) {
            if (!currentUser || !currentConversation) return;
            
            try {
                const messageRef = db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .doc(messageId);
                
                // Utiliser une transaction pour éviter les conflits
                await db.runTransaction(async (transaction) => {
                    const messageDoc = await transaction.get(messageRef);
                    
                    if (!messageDoc.exists) {
                        throw new Error('Message introuvable');
                    }
                    
                    const messageData = messageDoc.data();
                    const reactions = messageData.reactions || {};
                    const userReactions = reactions[emoji] || [];
                    const userIndex = userReactions.indexOf(currentUser.uid);
                    
                    if (userIndex > -1) {
                        // Retirer la réaction
                        userReactions.splice(userIndex, 1);
                        if (userReactions.length === 0) {
                            delete reactions[emoji];
                        } else {
                            reactions[emoji] = userReactions;
                        }
                    } else {
                        // Ajouter la réaction
                        reactions[emoji] = [...userReactions, currentUser.uid];
                    }
                    
                    // Mettre à jour avec la transaction
                    transaction.update(messageRef, { reactions });
                });
                
            } catch (error) {
                console.error('Erreur réaction:', error);
                showNotification('Erreur lors de la réaction', 'error');
            }
        }


        // Fermer modal
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        // Fermer modal en cliquant à l'extérieur
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.classList.remove('show');
            }
        });

        // Fermer emoji picker en cliquant à l'extérieur
        document.addEventListener('click', (e) => {
            const emojiPicker = document.getElementById('emojiPicker');
            if (!e.target.closest('.emoji-picker') && !e.target.matches('button[onclick="toggleEmojiPicker()"]')) {
                emojiPicker.classList.remove('show');
            }
        });

        // Notifications
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            notification.style.cssText = `
                position: fixed !important;
                bottom: 20px !important;
                right: 20px !important;
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'} !important;
                color: white !important;
                padding: 12px 16px !important;
                border-radius: 8px !important;
                z-index: 10000 !important;
                font-weight: 500 !important;
                font-size: 14px !important;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
                transform: translateX(400px) !important;
                transition: transform 0.3s ease !important;
                width: auto !important;
                height: auto !important;
                max-height: 50px !important;
                display: inline-block !important;
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                max-width: 300px !important;
                box-sizing: border-box !important;
            `;
            
            document.body.appendChild(notification);
            
            // Animation d'entrée
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Suppression automatique
            setTimeout(() => {
                notification.style.transform = 'translateX(400px)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }


        // Responsive - Toggle sidebar
        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('show');
        }

        // Responsive - Auto close sidebar on mobile when conversation is selected
        if (window.innerWidth <= 768) {
            document.addEventListener('click', (e) => {
                if (e.target.closest('.conversation-item')) {
                    document.getElementById('sidebar').classList.remove('show');
                }
            });
        }
        // Paramètres de conversation
        function openConversationSettings() {
            if (!currentConversation) {
                showNotification('Aucune conversation sélectionnée', 'warning');
                return;
            }
            
            // Pour l'instant, afficher les options simples
            const actions = [
                'Quitter la conversation',
                'Bloquer les participants',
                'Voir les participants'
            ];
            
            const action = prompt(`Conversation: ${currentConversation.name}\n\nChoisissez une action:\n1. Quitter la conversation\n2. Voir les participants\n3. Annuler`);
            
            switch(action) {
                case '1':
                    leaveConversation();
                    break;
                case '2':
                    showConversationParticipants();
                    break;
                default:
                    // Annuler
                    break;
            }
        }

        // Quitter une conversation
        async function leaveConversation() {
            if (!currentConversation || !confirm('Êtes-vous sûr de vouloir quitter cette conversation ?')) {
                return;
            }
            
            try {
                // Retirer l'utilisateur des participants
                await db.collection('conversations').doc(currentConversation.id).update({
                    participants: firebase.firestore.FieldValue.arrayRemove(currentUser.uid)
                });
                
                // Ajouter un message système
                await db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .add({
                        text: `${currentUser.displayName || 'Un utilisateur'} a quitté la conversation`,
                        senderId: 'system',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        type: 'system'
                    });
                
                showNotification('Vous avez quitté la conversation', 'success');
                
                // Recharger les conversations
                loadConversations();
                
                // Réinitialiser la vue
                currentConversation = null;
                document.getElementById('chatHeader').style.display = 'none';
                document.getElementById('messageInputContainer').style.display = 'none';
                document.getElementById('messagesContainer').innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                        <h3>Sélectionnez une conversation</h3>
                    </div>
                `;
                
            } catch (error) {
                showNotification('Erreur lors de la sortie de la conversation', 'error');
                console.error('Erreur:', error);
            }
        }

        // Afficher les participants
        async function showConversationParticipants() {
            if (!currentConversation) return;
            
            try {
                let participantsList = 'Participants de la conversation:\n\n';
                
                for (const participantId of currentConversation.participants) {
                    const userDoc = await db.collection('users').doc(participantId).get();
                    if (userDoc.exists) {
                        const userData = userDoc.data();
                        participantsList += `• ${userData.displayName} (${userData.userId})\n`;
                    }
                }
                
                alert(participantsList);
            } catch (error) {
                showNotification('Erreur lors du chargement des participants', 'error');
            }
        }

        function closeReactionMenu() {
            if (currentReactionMenu) {
                currentReactionMenu.remove();
                currentReactionMenu = null;
            }
            document.removeEventListener('click', closeReactionMenu);
        }


        // Supprimer un message
        function deleteMessage(messageId, messagePreview) {
            console.log('🗑️ deleteMessage appelée avec:', { messageId, messagePreview });
            
            if (!messageId) {
                console.error('❌ messageId manquant');
                showNotification('Erreur: ID du message manquant', 'error');
                return;
            }
            
            if (!currentConversation) {
                console.error('❌ Pas de conversation active');
                showNotification('Erreur: Aucune conversation active', 'error');
                return;
            }
            
            // ✅ Confirmation avec détails
            const confirmText = `Supprimer ce message ?\n\n"${(messagePreview || '').substring(0, 50)}${messagePreview && messagePreview.length > 50 ? '...' : ''}"`;
            
            if (!confirm(confirmText)) {
                console.log('🚫 Suppression annulée par l\'utilisateur');
                return;
            }
            
            console.log('💾 Suppression en cours...');
            
            try {
                const messageRef = db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .doc(messageId);
                
                // ✅ Vérification existence et propriétaire
                messageRef.get().then(doc => {
                    if (!doc.exists) {
                        throw new Error('Message introuvable');
                    }
                    
                    const messageData = doc.data();
                    if (messageData.senderId !== currentUser.uid) {
                        throw new Error('Vous ne pouvez supprimer que vos propres messages');
                    }
                    
                    // ✅ Suppression (soft delete)
                    return messageRef.update({
                        deleted: true,
                        deletedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        deletedBy: currentUser.uid
                    });
                })
                .then(() => {
                    console.log('✅ Message supprimé avec succès');
                    showNotification('Message supprimé', 'success');
                    notifyMessageDeletion(messageId);
                    updateRepliesAfterDeletion(messageId);
                })
                .catch(error => {
                    console.error('❌ Erreur lors de la suppression:', error);
                    
                    let errorMessage = 'Erreur lors de la suppression';
                    if (error.message.includes('introuvable')) {
                        errorMessage = 'Message introuvable';
                    } else if (error.message.includes('propres messages')) {
                        errorMessage = error.message;
                    } else if (error.message.includes('permission')) {
                        errorMessage = 'Permission refusée';
                    }
                    
                    showNotification(errorMessage, 'error');
                });
                
            } catch (error) {
                console.error('❌ Erreur inattendue:', error);
                showNotification('Erreur inattendue lors de la suppression', 'error');
            }
}
        // Afficher la carte de profil utilisateur
        async function showUserProfile(userId) {
            if (userId === 'system' || userId === currentUser.uid) {
                if (userId === currentUser.uid) {
                    showNotification('C\'est votre propre profil !', 'info');
                }
                return;
            }
            
            try {
                // Récupérer les informations utilisateur
                const userDoc = await db.collection('users').doc(userId).get();
                if (!userDoc.exists) {
                    showNotification('Utilisateur non trouvé', 'error');
                    return;
                }
                
                const userData = userDoc.data();
                
                // Vérifier si l'utilisateur est bloqué
                const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
                const blockedUsers = currentUserDoc.data().blockedUsers || [];
                const isBlocked = blockedUsers.includes(userId);
                
                // Vérifier s'il existe déjà une conversation privée
                const existingConv = await db.collection('conversations')
                    .where('participants', 'array-contains', currentUser.uid)
                    .where('isGroup', '==', false)
                    .get();
                
                let privateConvId = null;
                for (const doc of existingConv.docs) {
                    const conv = doc.data();
                    if (conv.participants.length === 2 && conv.participants.includes(userId)) {
                        privateConvId = doc.id;
                        break;
                    }
                }
                
                // Créer la carte de profil
                showUserCard(userData, userId, isBlocked, privateConvId);
                
            } catch (error) {
                showNotification('Erreur lors du chargement du profil', 'error');
                console.error('Erreur:', error);
            }
        }

        // Afficher la carte utilisateur
        function showUserCard(userData, userId, isBlocked, existingConvId) {
            // Supprimer l'ancienne carte si elle existe
            const oldCard = document.getElementById('userProfileCard');
            if (oldCard) oldCard.remove();
            
            // Créer la carte
            const card = document.createElement('div');
            card.id = 'userProfileCard';
            card.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.9);
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 20px;
                padding: 25px;
                z-index: 1000;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                backdrop-filter: blur(10px);
                max-width: 400px;
                width: 90%;
                animation: cardSlideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
            `;
            
            const createdDate = userData.createdAt ? 
                userData.createdAt.toDate().toLocaleDateString('fr-FR', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                }) : 'Date inconnue';
            
            card.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="
                        width: 80px;
                        height: 80px;
                        border-radius: 50%;
                        background: linear-gradient(135deg, var(--primary), var(--accent));
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 32px;
                        font-weight: bold;
                        margin: 0 auto 15px;
                        color: white;
                        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
                    ">
                        ${userData.displayName.charAt(0).toUpperCase()}
                    </div>
                    <h3 style="margin: 0; color: var(--text-primary);">${userData.displayName}</h3>
                    <p style="color: var(--accent); font-family: 'Courier New', monospace; font-weight: 600; margin: 5px 0;">
                        ${userData.userId}
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; margin-bottom: 10px; color: var(--text-secondary);">
                        <span style="margin-right: 10px;">📧</span>
                        <span>${userData.email}</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 10px; color: var(--text-secondary);">
                        <span style="margin-right: 10px;">📅</span>
                        <span>Membre depuis le ${createdDate}</span>
                    </div>
                    ${isBlocked ? `
                        <div style="display: flex; align-items: center; margin-bottom: 10px; color: var(--danger);">
                            <span style="margin-right: 10px;">🚫</span>
                            <span>Utilisateur bloqué</span>
                        </div>
                    ` : ''}
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    ${!isBlocked ? `
                        <button class="btn btn-primary btn-small" onclick="handlePrivateConversation('${userId}', '${existingConvId}', '${userData.displayName}')">
                            ${existingConvId ? '💬 Ouvrir discussion' : '💬 Message privé'}
                        </button>
                        <button class="btn btn-danger btn-small" onclick="blockUser('${userId}', '${userData.displayName}')">
                            🚫 Bloquer
                        </button>
                    ` : `
                        <button class="btn btn-success btn-small" onclick="unblockUser('${userId}', '${userData.displayName}')" style="grid-column: 1 / -1;">
                            ✅ Débloquer utilisateur
                        </button>
                    `}
                </div>
                
                <button class="btn btn-secondary" onclick="closeUserCard()" style="width: 100%;">
                    Fermer
                </button>
            `;
            
            // Ajouter les styles d'animation
            if (!document.getElementById('userCardStyles')) {
                const style = document.createElement('style');
                style.id = 'userCardStyles';
                style.textContent = `
                    @keyframes cardSlideIn {
                        from {
                            opacity: 0;
                            transform: translate(-50%, -60%) scale(0.8);
                        }
                        to {
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 999;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            
            overlay.onclick = closeUserCard;
            
            document.body.appendChild(overlay);
            document.body.appendChild(card);
            
            setTimeout(() => overlay.style.opacity = '1', 10);
        }

        // Fermer la carte utilisateur
        function closeUserCard() {
            const card = document.getElementById('userProfileCard');
            const overlay = document.querySelector('div[style*="position: fixed"][style*="z-index: 999"]');
            
            if (card) card.remove();
            if (overlay) overlay.remove();
        }
        // Gérer les conversations privées
        async function handlePrivateConversation(userId, existingConvId, userName) {
            try {
                if (existingConvId && existingConvId !== 'null') {
                    // Ouvrir la conversation existante
                    const convDoc = await db.collection('conversations').doc(existingConvId).get();
                    if (convDoc.exists) {
                        const convData = convDoc.data();
                        openConversation(existingConvId, convData);
                        closeUserCard();
                        showNotification(`Conversation avec ${userName} ouverte`, 'success');
                        return;
                    }
                }
                
                // Créer une nouvelle conversation privée
                const newConv = await db.collection('conversations').add({
                    name: `${userName}`,
                    participants: [currentUser.uid, userId],
                    isGroup: false,
                    createdBy: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: '',
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                showNotification(`Conversation privée créée avec ${userName}`, 'success');
                closeUserCard();
                loadConversations();
                
                // Ouvrir automatiquement la nouvelle conversation
                setTimeout(() => {
                    const convData = {
                        name: userName,
                        participants: [currentUser.uid, userId],
                        isGroup: false
                    };
                    openConversation(newConv.id, convData);
                }, 500);
                
            } catch (error) {
                showNotification('Erreur lors de la création de la conversation', 'error');
                console.error('Erreur:', error);
            }
        }
        // Bloquer un utilisateur
        async function blockUser(userId, userName) {
            if (!confirm(`Êtes-vous sûr de vouloir bloquer ${userName} ?\n\n⚠️ Cela va :\n- Supprimer votre conversation privée avec cette personne\n- Masquer ses messages dans les groupes`)) {
                return;
            }
            
            try {
                // 1. Ajouter à la liste des bloqués
                await db.collection('users').doc(currentUser.uid).update({
                    blockedUsers: firebase.firestore.FieldValue.arrayUnion(userId)
                });
                
                // 2. Trouver et supprimer la conversation privée avec cet utilisateur
                const privateConversations = await db.collection('conversations')
                    .where('participants', 'array-contains', currentUser.uid)
                    .where('isGroup', '==', false)
                    .get();
                
                for (const doc of privateConversations.docs) {
                    const conv = doc.data();
                    if (conv.participants.length === 2 && conv.participants.includes(userId)) {
                        // Supprimer la conversation privée
                        await db.collection('conversations').doc(doc.id).delete();
                        console.log(`Conversation privée supprimée avec ${userName}`);
                        break;
                    }
                }
                
                showNotification(`${userName} a été bloqué et votre conversation privée supprimée`, 'success');
                closeUserCard();
                
                // Recharger les conversations et fermer la conversation actuelle si nécessaire
                if (currentConversation && 
                    !currentConversation.isGroup && 
                    currentConversation.participants.includes(userId)) {
                    
                    // Fermer la conversation actuelle
                    currentConversation = null;
                    document.getElementById('chatHeader').style.display = 'none';
                    document.getElementById('messageInputContainer').style.display = 'none';
                    document.getElementById('messagesContainer').innerHTML = `
                        <div style="text-align: center; color: var(--text-secondary); margin-top: 50px;">
                            <h3>Conversation supprimée</h3>
                            <p>Vous avez bloqué cet utilisateur</p>
                        </div>
                    `;
                }
                
                loadConversations();
                
                // Si on est dans un groupe, recharger les messages pour masquer ceux de l'utilisateur bloqué
                if (currentConversation && currentConversation.isGroup) {
                    loadMessages(currentConversation.id);
                }
                
            } catch (error) {
                showNotification('Erreur lors du blocage', 'error');
                console.error('Erreur:', error);
            }
        }


        // Débloquer un utilisateur (depuis la carte de profil)
        async function unblockUser(userId, userName) {
            try {
                await db.collection('users').doc(currentUser.uid).update({
                    blockedUsers: firebase.firestore.FieldValue.arrayRemove(userId)
                });
                
                showNotification(`${userName} a été débloqué`, 'success');
                closeUserCard();
                
            } catch (error) {
                showNotification('Erreur lors du déblocage', 'error');
                console.error('Erreur:', error);
            }
        }
        // Afficher un message bloqué temporairement
        function toggleBlockedMessage(messageElement, messageId, originalText) {
            const messageText = messageElement.querySelector('.message-text');
            const currentText = messageText.textContent;
            
            // Décoder le texte HTML si nécessaire
            const decodedText = originalText.replace(/\\'/g, "'").replace(/&quot;/g, '"').replace(/&amp;/g, '&');
            
            if (currentText.includes('Message masqué')) {
                // Afficher le message original temporairement
                messageText.textContent = decodedText;
                messageText.style.opacity = '0.8';
                messageText.style.fontStyle = 'normal';
                messageText.style.color = 'var(--text-primary)';
                messageElement.style.background = 'rgba(239, 68, 68, 0.1)';
                messageElement.classList.add('revealed');
                
                console.log('Message révélé:', decodedText);
                
                // Masquer à nouveau après 8 secondes avec compte à rebours
                let countdown = 8;
                const countdownInterval = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        messageText.textContent = `${decodedText} (masquage dans ${countdown}s)`;
                    } else {
                        clearInterval(countdownInterval);
                        messageText.textContent = 'Message masqué (utilisateur bloqué) - Cliquez pour afficher temporairement';
                        messageText.style.opacity = '0.4';
                        messageText.style.fontStyle = 'italic';
                        messageText.style.color = '#666';
                        messageElement.style.background = 'rgba(0,0,0,0.1)';
                        messageElement.classList.remove('revealed');
                    }
                }, 1000);
                
                // Permettre de re-masquer en cliquant à nouveau
                setTimeout(() => {
                    const clickToHide = () => {
                        clearInterval(countdownInterval);
                        messageText.textContent = 'Message masqué (utilisateur bloqué) - Cliquez pour afficher temporairement';
                        messageText.style.opacity = '0.4';
                        messageText.style.fontStyle = 'italic';
                        messageText.style.color = '#666';
                        messageElement.style.background = 'rgba(0,0,0,0.1)';
                        messageElement.classList.remove('revealed');
                        messageElement.removeEventListener('click', clickToHide);
                    };
                    messageElement.addEventListener('click', clickToHide);
                }, 1000);
            }
        }


        // Vérifier si un utilisateur est bloqué
        async function isUserBlocked(userId) {
            try {
                const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
                const blockedUsers = currentUserDoc.data().blockedUsers || [];
                return blockedUsers.includes(userId);
            } catch (error) {
                console.error('Erreur lors de la vérification du blocage:', error);
                return false;
            }
        }
        // Modifier un message
        async function editMessage(messageId, currentText = null) {
            console.log('✏️ editMessage appelée avec:', { messageId, currentText });
            
            // ✅ Validation des paramètres
            if (!messageId) {
                console.error('❌ messageId manquant');
                showNotification('Erreur: ID du message manquant', 'error');
                return;
            }
            
            if (!currentConversation) {
                console.error('❌ Pas de conversation active');
                showNotification('Erreur: Aucune conversation active', 'error');
                return;
            }
            
            // ✅ Récupérer le texte depuis l'attribut data si pas fourni
            if (!currentText) {
                const button = event?.target;
                if (button) {
                    currentText = button.getAttribute('data-message-text') || '';
                }
                
                // Si toujours pas de texte, essayer de le récupérer du DOM
                if (!currentText) {
                    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (messageElement) {
                        const textElement = messageElement.querySelector('.message-text');
                        currentText = textElement?.textContent || '';
                    }
                }
            }
            
            // ✅ Nettoyer le texte actuel
            currentText = (currentText || '').trim();
            
            console.log('📝 Texte actuel à éditer:', currentText);
            
            // ✅ Demander le nouveau texte
            const newText = prompt('Modifier votre message :', currentText);
            
            // ✅ Vérifications avant sauvegarde
            if (newText === null) {
                console.log('🚫 Édition annulée par l\'utilisateur');
                return; // Utilisateur a annulé
            }
            
            const trimmedNewText = newText.trim();
            
            if (trimmedNewText === '') {
                showNotification('Le message ne peut pas être vide', 'warning');
                return;
            }
            
            if (trimmedNewText === currentText) {
                console.log('📝 Aucun changement détecté');
                return; // Pas de changement
            }
            
            try {
                console.log('💾 Sauvegarde du message modifié...');
                
                const messageRef = db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .doc(messageId);
                
                // ✅ Vérifier que le message existe et appartient à l'utilisateur
                const messageDoc = await messageRef.get();
                if (!messageDoc.exists) {
                    throw new Error('Message introuvable');
                }
                
                const messageData = messageDoc.data();
                if (messageData.senderId !== currentUser.uid) {
                    throw new Error('Vous ne pouvez modifier que vos propres messages');
                }
                
                // ✅ Sauvegarder l'original uniquement si c'est la première modification
                const updateData = {
                    text: trimmedNewText,
                    edited: true,
                    editedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // ✅ Conserver le texte original seulement lors de la première édition
                if (!messageData.edited && !messageData.originalText) {
                    updateData.originalText = currentText;
                }
                
                await messageRef.update(updateData);
                
                console.log('✅ Message modifié avec succès');
                showNotification('Message modifié', 'success');
                
            } catch (error) {
                console.error('❌ Erreur lors de la modification:', error);
                
                let errorMessage = 'Erreur lors de la modification';
                if (error.message.includes('permission')) {
                    errorMessage = 'Vous n\'avez pas la permission de modifier ce message';
                } else if (error.message.includes('introuvable')) {
                    errorMessage = 'Message introuvable';
                } else if (error.message.includes('propres messages')) {
                    errorMessage = error.message;
                }
                
                showNotification(errorMessage, 'error');
            }
        }

        // Répondre à un message
        function replyToMessage(messageId, messageText, senderName) {
            console.log('🎯 replyToMessage appelée avec:', { messageId, messageText, senderName });
            
            // ✅ Validation des paramètres
            if (!messageId) {
                console.error('❌ messageId manquant');
                return;
            }
            
            // ✅ Nettoyer les paramètres (au cas où ils contiennent des caractères bizarres)
            const cleanMessageText = messageText || 'Message';
            const cleanSenderName = senderName || 'Utilisateur';
            
            console.log('✅ Paramètres nettoyés:', { 
                messageId, 
                cleanMessageText, 
                cleanSenderName 
            });
            
            // ✅ Appeler showReplyPreview
            showReplyPreview(messageId, cleanMessageText, cleanSenderName);
        }


        function showReplyPreview(messageId, messageText, senderName) {
            console.log('🎯 showReplyPreview appelée avec:', { messageId, messageText, senderName });
            
            // ✅ Définir currentReplyId
            currentReplyId = messageId;
            console.log('✅ currentReplyId défini:', currentReplyId);
            
            // ✅ Supprimer l'ancienne preview
            const existingPreview = document.getElementById('reply-preview');
            if (existingPreview) {
                existingPreview.remove();
            }
            
            // ✅ Créer la nouvelle preview
            const replyPreview = document.createElement('div');
            replyPreview.id = 'reply-preview';
            replyPreview.innerHTML = `
                <div style="
                    background: var(--bg-secondary, #2a2a2a); 
                    padding: 12px; 
                    margin: 8px 0; 
                    border-left: 3px solid var(--primary, #007bff); 
                    border-radius: 8px; 
                    display: flex; 
                    justify-content: space-between; 
                    align-items: center;
                    color: var(--text-primary, white);
                ">
                    <div style="flex: 1;">
                        <div style="font-size: 12px; color: var(--primary, #007bff); margin-bottom: 4px; font-weight: bold;">
                            Répondre à ${senderName}
                        </div>
                        <div style="font-size: 14px; color: var(--text-secondary, #ccc);">
                            ${messageText}
                        </div>
                    </div>
                    <button id="cancel-reply-btn" style="
                        background: none; 
                        border: none; 
                        color: var(--text-secondary, #999); 
                        cursor: pointer; 
                        font-size: 20px; 
                        padding: 8px;
                    ">✕</button>
                </div>
            `;
            
            // ✅ Insérer la preview avant l'input
            const messageInput = document.getElementById('messageInput');
            if (messageInput && messageInput.parentNode) {
                messageInput.parentNode.insertBefore(replyPreview, messageInput);
                console.log('✅ Preview insérée');
            }
            
            // ✅ Event listener pour le bouton annuler
            const cancelBtn = document.getElementById('cancel-reply-btn');
            if (cancelBtn) {
                cancelBtn.onclick = function(e) {
                    e.preventDefault();
                    console.log('🗑️ Annulation de la réponse');
                    clearReplyMode();
                };
            }
            
            // ✅ Focus sur l'input
            messageInput.focus();
            
            console.log('✅ Preview créée avec currentReplyId:', currentReplyId);
        }


        // ✅ Annuler la réponse
        function cancelReply() {
            console.log('❌ Annulation réponse');
            currentReply = null;
            
            const replyPreview = document.getElementById('replyPreview');
            if (replyPreview) {
                replyPreview.style.display = 'none';
            }
            
            document.getElementById('messageInput').focus();
        }

        // Afficher l'interface de réponse
        function showReplyInterface() {
            const messageInputContainer = document.getElementById('messageInputContainer');
            
            // Supprimer l'ancienne interface de réponse si elle existe
            const existingReply = document.getElementById('replyInterface');
            if (existingReply) {
                existingReply.remove();
            }
            // Créer l'interface de réponse
            const replyInterface = document.createElement('div');
            replyInterface.id = 'replyInterface';
            replyInterface.style.cssText = `
                background: var(--bg-tertiary);
                border: 1px solid var(--border);
                border-radius: 12px 12px 0 0;
                padding: 12px 20px;
                margin: 0 20px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                animation: slideDown 0.3s ease;
            `;
            
            replyInterface.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="color: var(--primary); font-size: 18px;">↳</div>
                    <div>
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 2px;">
                            Réponse à ${window.replyingTo.author}
                        </div>
                        <div style="font-size: 14px; color: var(--text-primary); opacity: 0.8;">
                            ${window.replyingTo.text}
                        </div>
                    </div>
                </div>
                <button onclick="console.log('Bouton cliqué!'); cancelReply(); console.log('cancelReply terminée');" style="
                    background: none;
                    border: none;
                    color: var(--text-secondary);
                    cursor: pointer;
                    padding: 5px;
                    border-radius: 50%;
                    transition: all 0.3s ease;
                " onmouseover="this.style.background='var(--bg-secondary)'; this.style.color='var(--text-primary)'"
                onmouseout="this.style.background='none'; this.style.color='var(--text-secondary)'">
                    ✕
                </button>
            `;
            
            // Insérer avant le conteneur de saisie
            messageInputContainer.parentNode.insertBefore(replyInterface, messageInputContainer);
        }


        // Ajouter les animations CSS pour les réponses
        if (!document.getElementById('replyAnimations')) {
            const style = document.createElement('style');
            style.id = 'replyAnimations';
            style.textContent = `
                @keyframes slideDown {
                    from {
                        opacity: 0;
                        transform: translateY(-20px);
                        max-height: 0;
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0);
                        max-height: 100px;
                    }
                }
                
                @keyframes slideUp {
                    from {
                        opacity: 1;
                        transform: translateY(0);
                        max-height: 100px;
                    }
                    to {
                        opacity: 0;
                        transform: translateY(-20px);
                        max-height: 0;
                    }
                }
                
                .reply-bubble {
                    background: var(--bg-tertiary) !important;
                    border-left: 3px solid var(--primary);
                    margin-bottom: 8px;
                    padding: 8px 12px;
                    border-radius: 8px;
                    font-size: 13px;
                    opacity: 0.8;
                }
                
                .reply-author {
                    color: var(--primary);
                    font-weight: 600;
                    font-size: 11px;
                    margin-bottom: 2px;
                }
                
                .reply-text {
                    color: var(--text-secondary);
                    line-height: 1.3;
                }
                
                .edited-indicator {
                    font-size: 11px;
                    color: var(--text-secondary);
                    font-style: italic;
                    opacity: 0.7;
                    margin-top: 4px;
                }
            `;
            document.head.appendChild(style);
        }
        function scrollToMessage(messageId) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                messageElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
                
                // Effet de surbrillance temporaire
                messageElement.style.background = 'rgba(102, 126, 234, 0.2)';
                messageElement.style.transition = 'background 0.3s ease';
                
                setTimeout(() => {
                    messageElement.style.background = '';
                }, 2000);
            } else {
                showNotification('Message original non trouvé', 'warning');
            }
        }
        // Gestion du pop-up de don
        function showDonationPopup() {
            const popup = document.getElementById('donationPopup');
            popup.classList.add('show');
            
            // Désactiver le scroll de la page
            document.body.style.overflow = 'hidden';
        }

        function closeDonationPopup() {
            const popup = document.getElementById('donationPopup');
            popup.classList.remove('show');
            
            // Réactiver le scroll de la page
            document.body.style.overflow = 'auto';
            
            // Marquer comme vu pour cette session
            sessionStorage.setItem('donationPopupShown', 'true');
        }

        // Afficher le pop-up au chargement (seulement si pas déjà vu dans cette session)
        window.addEventListener('load', () => {
            // Attendre 2 secondes après le chargement complet
            setTimeout(() => {
                if (!sessionStorage.getItem('donationPopupShown')) {
                    showDonationPopup();
                }
            }, 2000);
        });

        // Afficher le pop-up quand l'utilisateur est connecté
        auth.onAuthStateChanged((user) => {
            if (user && !sessionStorage.getItem('donationPopupShown')) {
                setTimeout(() => {
                    showDonationPopup();
                }, 3000);
            }
        });
        // Configuration Cloudinary
        const CLOUDINARY_CONFIG = {
            cloudName: 'dthgc6znq',
            uploadPreset: 'ulyra-chat' // Assure-toi d'avoir créé ce preset
        };

        // Sélectionner une image (version Cloudinary)
        function selectImage() {
            const widget = cloudinary.createUploadWidget({
                cloudName: CLOUDINARY_CONFIG.cloudName,
                uploadPreset: CLOUDINARY_CONFIG.uploadPreset,
                multiple: false,
                maxFileSize: 5000000,
                folder: `conversations/${currentConversation.id}/images`,
                
                // ENLEVER TOUTE LA MODÉRATION AUTOMATIQUE
                // moderation: 'ai_vision', ❌
                // rejection_questions: [...], ❌
                // auto_moderate: true, ❌
                
                sources: ['local', 'camera'],
                styles: {
                    palette: {
                        window: '#ffffff',
                        sourceBg: '#f4f4f5',
                        windowBorder: '#667eea',
                        tabIcon: '#667eea',
                        inactiveTabIcon: '#999999',
                        menuIcons: '#667eea',
                        link: '#667eea',
                        action: '#667eea',
                        inProgress: '#667eea',
                        complete: '#4CAF50',
                        error: '#f44336',
                        textDark: '#000000',
                        textLight: '#ffffff'
                    }
                }
            }, (error, result) => {
                if (!error && result && result.event === "success") {
                    // Envoi direct sans vérification automatique
                    console.log('Image uploadée:', result.info);
                    sendImageMessage(result.info);
                } else if (error) {
                    console.error('Erreur upload:', error);
                    showNotification('Erreur lors de l\'upload', 'error');
                }
            });

            widget.open();
        }

        // Envoyer un message image via Cloudinary (remplace uploadAndSendImage)
        async function sendImageMessage(imageInfo) {
            if (!currentConversation) return;
            
            try {
                showNotification('📤 Envoi de l\'image en cours...', 'info');
                
                const messageData = {
                    type: 'image',
                    imageUrl: imageInfo.secure_url, // URL Cloudinary sécurisée
                    imageName: imageInfo.original_filename || 'Image',
                    imageSize: imageInfo.bytes,
                    width: imageInfo.width,
                    height: imageInfo.height,
                    senderId: currentUser.uid,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    reactions: {}
                };
                
                // Ajouter les informations de réponse si applicable
                if (window.replyingTo) {
                    messageData.replyTo = {
                        messageId: window.replyingTo.messageId,
                        text: window.replyingTo.text,
                        author: window.replyingTo.author
                    };
                }
                
                await db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .add(messageData);
                
                // Mettre à jour le dernier message de la conversation
                await db.collection('conversations').doc(currentConversation.id).update({
                    lastMessage: '📷 Photo',
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                showNotification('Photo envoyée avec succès ! 📷', 'success');
                
                // Annuler la réponse si applicable
                if (window.replyingTo) {
                    cancelReply();
                }
                
            } catch (error) {
                console.error('Erreur lors de l\'envoi:', error);
                showNotification('Erreur lors de l\'envoi du message', 'error');
            }
        }

        // Ouvrir l'image en modal (inchangée)
        function openImageModal(url) {
            document.body.classList.add('modal-open');
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
                padding: 20px; box-sizing: border-box;
            `;
            
            modal.innerHTML = `
                <div style="position: relative; max-width: 90vw; max-height: 90vh; display: flex; align-items: center; justify-content: center;">
                    <img src="${url}" style="max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 8px;">
                    <button onclick="this.closest('.modal-overlay').remove()" 
                            style="position: absolute; top: -40px; right: -40px; background: rgba(255,255,255,0.9); color: #333; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 20px; font-weight: bold; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">✕</button>
                </div>
            `;
            
            modal.className = 'modal-overlay';
            document.body.appendChild(modal);
            
            // ✅ Fermeture par clic sur l'arrière-plan
            modal.onclick = () => {
                modal.remove();
                document.body.classList.remove('modal-open'); // ✅ Restaurer le scroll
            };
        }

        // Fermer le modal d'image (inchangée)
        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            if (modal) modal.remove();
        }
        // Afficher l'interface de signalement moderne
        function showReportInterface(messageId, imageName) {
            // Supprimer l'ancienne interface
            const existingReport = document.getElementById('reportInterface');
            if (existingReport) existingReport.remove();
            
            const reportInterface = document.createElement('div');
            reportInterface.id = 'reportInterface';
            reportInterface.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.9);
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 20px;
                padding: 25px;
                z-index: 2000;
                box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                max-width: 450px;
                width: 90%;
                animation: reportSlideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
            `;
            
            reportInterface.innerHTML = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <h3 style="color: var(--danger); margin: 0 0 10px;">🚨 Signaler ce contenu</h3>
                    <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                        Image : ${imageName}
                    </p>
                </div>
                
                <div style="margin-bottom: 25px;">
                    <p style="margin-bottom: 15px; font-weight: 600;">Pourquoi signalez-vous cette image ?</p>
                    <div id="reportReasons" style="display: grid; gap: 10px;">
                        <label class="report-reason" data-reason="nudity">
                            <input type="checkbox" value="nudity">
                            <span class="checkmark">🔞</span>
                            <span class="reason-text">Nudité / Contenu sexuel</span>
                        </label>
                        <label class="report-reason" data-reason="violence">
                            <input type="checkbox" value="violence">
                            <span class="checkmark">⚔️</span>
                            <span class="reason-text">Violence / Contenu gore</span>
                        </label>
                        <label class="report-reason" data-reason="harassment">
                            <input type="checkbox" value="harassment">
                            <span class="checkmark">💬</span>
                            <span class="reason-text">Harcèlement / Intimidation</span>
                        </label>
                        <label class="report-reason" data-reason="hate">
                            <input type="checkbox" value="hate">
                            <span class="checkmark">😡</span>
                            <span class="reason-text">Discours de haine / Discrimination</span>
                        </label>
                        <label class="report-reason" data-reason="spam">
                            <input type="checkbox" value="spam">
                            <span class="checkmark">📢</span>
                            <span class="reason-text">Spam / Contenu indésirable</span>
                        </label>
                        <label class="report-reason" data-reason="illegal">
                            <input type="checkbox" value="illegal">
                            <span class="checkmark">🚔</span>
                            <span class="reason-text">Contenu illégal</span>
                        </label>
                        <label class="report-reason" data-reason="other">
                            <input type="checkbox" value="other">
                            <span class="checkmark">❓</span>
                            <span class="reason-text">Autre raison</span>
                        </label>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="submitReport('${messageId}')" class="btn btn-danger" id="submitReportBtn">
                        🚨 Envoyer le signalement
                    </button>
                    <button onclick="closeReportInterface()" class="btn btn-secondary">
                        ❌ Annuler
                    </button>
                </div>
            `;
            
            // Overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.6);
                z-index: 1999;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            overlay.onclick = closeReportInterface;
            
            document.body.appendChild(overlay);
            document.body.appendChild(reportInterface);
            
            setTimeout(() => overlay.style.opacity = '1', 10);
        }

        // Fermer l'interface de signalement
        function closeReportInterface() {
            const reportInterface = document.getElementById('reportInterface');
            const overlay = document.querySelector('div[style*="z-index: 1999"]');
            
            if (reportInterface) reportInterface.remove();
            if (overlay) overlay.remove();
        }
        // Envoyer un signalement
        async function submitReport(messageId) {
            const selectedReasons = [];
            const checkboxes = document.querySelectorAll('#reportReasons input[type="checkbox"]:checked');
            
            checkboxes.forEach(checkbox => {
                selectedReasons.push(checkbox.value);
            });
            
            if (selectedReasons.length === 0) {
                showNotification('Veuillez sélectionner au moins une raison', 'warning');
                return;
            }
            
            try {
                // Vérifier si l'utilisateur a déjà signalé cette image
                const existingReport = await db.collection('reports')
                    .where('messageId', '==', messageId)
                    .where('reportedBy', '==', currentUser.uid)
                    .get();
                
                if (!existingReport.empty) {
                    showNotification('Vous avez déjà signalé cette image', 'warning');
                    closeReportInterface();
                    return;
                }
                
                // Enregistrer le signalement
                await db.collection('reports').add({
                    messageId: messageId,
                    reportedBy: currentUser.uid,
                    reasons: selectedReasons,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    status: 'pending'
                });
                
                showNotification('Signalement envoyé avec succès', 'success');
                closeReportInterface();
                
                // Mettre à jour l'affichage du message
                updateMessageReportStatus(messageId);
                
            } catch (error) {
                console.error('Erreur signalement:', error);
                showNotification('Erreur lors du signalement', 'error');
            }
        }

        // Mettre à jour le statut de signalement d'un message
        async function updateMessageReportStatus(messageId) {
            try {
                // Compter les signalements pour ce message
                const reports = await db.collection('reports')
                    .where('messageId', '==', messageId)
                    .get();
                
                const reportCount = reports.size;
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                
                if (!messageElement) return;
                
                const imageElement = messageElement.querySelector('img');
                if (!imageElement) return;
                
                // Supprimer les anciens overlays
                const existingOverlay = messageElement.querySelector('.report-overlay');
                if (existingOverlay) existingOverlay.remove();
                
                if (reportCount >= 5) {
                    // 5+ signalements : Remplacer par message de suppression
                    replaceImageWithDeletionMessage(messageElement, messageId, reports);
                } else if (reportCount >= 3) {
                    // 3-4 signalements : Flouter fortement avec re-flou automatique
                    applyHeavyBlur(imageElement, messageElement);
                } else if (reportCount >= 2) {
                    // 2 signalements : Flouter avec possibilité de voir
                    applyLightBlur(imageElement, messageElement);
                }
                
            } catch (error) {
                console.error('Erreur mise à jour statut:', error);
            }
        }

        // Appliquer un flou léger (2 signalements)
        function applyLightBlur(imageElement, messageElement) {
            imageElement.classList.add('image-reported');
            
            const overlay = document.createElement('div');
            overlay.className = 'report-overlay';
            overlay.textContent = '👁️ Image signalée - Cliquer pour voir';
            overlay.onclick = () => {
                imageElement.style.filter = 'none';
                overlay.style.display = 'none';
                
                // Re-flouter après 10 secondes
                setTimeout(() => {
                    if (imageElement.classList.contains('image-reported')) {
                        imageElement.style.filter = 'blur(10px)';
                        overlay.style.display = 'block';
                    }
                }, 10000);
            };
            
            messageElement.querySelector('.message-bubble').appendChild(overlay);
        }

        // Appliquer un flou fort (3-4 signalements)
        function applyHeavyBlur(imageElement, messageElement) {
            imageElement.classList.add('image-heavily-reported');
            
            const overlay = document.createElement('div');
            overlay.className = 'report-overlay';
            overlay.innerHTML = '⚠️ Image fortement signalée<br>Cliquer pour voir (5s)';
            overlay.onclick = () => {
                imageElement.style.filter = 'none';
                overlay.style.display = 'none';
                
                // Re-flouter après 5 secondes
                setTimeout(() => {
                    if (imageElement.classList.contains('image-heavily-reported')) {
                        imageElement.style.filter = 'blur(15px) brightness(0.5)';
                        overlay.style.display = 'block';
                    }
                }, 5000);
            };
            
            messageElement.querySelector('.message-bubble').appendChild(overlay);
            
            // Désactiver l'agrandissement
            imageElement.onclick = (e) => {
                e.preventDefault();
                showNotification('Cette image a été signalée plusieurs fois', 'warning');
            };
        }

        // Remplacer l'image par un message de suppression (5+ signalements)
        async function replaceImageWithDeletionMessage(messageElement, messageId, reports) {
            // Calculer les raisons les plus fréquentes
            const reasonCounts = {};
            reports.forEach(report => {
                const data = report.data();
                data.reasons.forEach(reason => {
                    reasonCounts[reason] = (reasonCounts[reason] || 0) + 1;
                });
            });
            
            const maxCount = Math.max(...Object.values(reasonCounts));
            const topReasons = Object.keys(reasonCounts).filter(reason => reasonCounts[reason] === maxCount);
            
            const reasonNames = {
                'nudity': 'Nudité / Contenu sexuel',
                'violence': 'Violence / Contenu gore',
                'harassment': 'Harcèlement',
                'hate': 'Discours de haine',
                'spam': 'Spam',
                'illegal': 'Contenu illégal',
                'other': 'Autre'
            };
            
            const messageBubble = messageElement.querySelector('.message-bubble');
            messageBubble.innerHTML = `
                <div class="image-deleted-message">
                    <h4 style="margin: 0 0 10px; color: var(--danger);">🚫 Image supprimée</h4>
                    <p style="margin: 0 0 15px; color: var(--text-secondary);">
                        Cette image a été supprimée suite à ${reports.size} signalements.
                    </p>
                    <button onclick="showReportReasons(['${topReasons.join("', '")}'])" 
                            class="btn btn-secondary btn-small">
                        📊 Voir les raisons
                    </button>
                </div>
            `;
        }

        // Afficher les raisons de signalement
        function showReportReasons(reasons) {
            const reasonNames = {
                'nudity': 'Nudité / Contenu sexuel',
                'violence': 'Violence / Contenu gore', 
                'harassment': 'Harcèlement',
                'hate': 'Discours de haine',
                'spam': 'Spam',
                'illegal': 'Contenu illégal',
                'other': 'Autre'
            };
            
            const reasonList = reasons.map(r => reasonNames[r] || r).join('\n• ');
            alert(`Raisons principales du signalement :\n\n• ${reasonList}`);
        }
        // Vérifier les signalements au chargement des messages
        async function checkExistingReports() {
            const messageElements = document.querySelectorAll('[data-message-id]');
            
            for (const element of messageElements) {
                const messageId = element.dataset.messageId;
                if (element.querySelector('img')) {
                    await updateMessageReportStatus(messageId);
                }
            }
        }
        // Créer ou trouver une discussion privée
        async function createOrFindPrivateConversation(otherUserId) {
            try {
                // Chercher une discussion existante entre les deux utilisateurs
                const existingConversation = await db.collection('conversations')
                    .where('participants', 'array-contains', currentUser.uid)
                    .where('type', '==', 'private')
                    .get();
                
                // Vérifier si une discussion privée existe déjà
                for (const doc of existingConversation.docs) {
                    const data = doc.data();
                    if (data.participants.includes(otherUserId) && data.participants.length === 2) {
                        // Discussion trouvée, l'ouvrir
                        await selectConversation(doc.id, data);
                        return;
                    }
                }
                
                // Aucune discussion trouvée, en créer une nouvelle
                await createPrivateConversation(otherUserId);
                
            } catch (error) {
                console.error('Erreur lors de la recherche/création de discussion:', error);
                showNotification('Erreur lors de l\'ouverture de la discussion', 'error');
            }
        }

        // Créer une nouvelle discussion privée (version corrigée)
        async function createPrivateConversation(otherUserId) {
            try {
                // Récupérer les infos des deux utilisateurs
                const otherUserDoc = await db.collection('users').doc(otherUserId).get();
                if (!otherUserDoc.exists) {
                    showNotification('Utilisateur introuvable', 'error');
                    return;
                }
                
                const otherUserData = otherUserDoc.data();
                const currentUserDoc = await db.collection('users').doc(currentUser.uid).get();
                const currentUserData = currentUserDoc.data();
                
                // Créer la conversation privée avec participantNames CORRECT
                const conversationData = {
                    participants: [currentUser.uid, otherUserId],
                    type: 'private',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: '',
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                    // CORRECTION : Objet participantNames bien formé
                    participantNames: {
                        [currentUser.uid]: currentUserData.displayName || 'Utilisateur',
                        [otherUserId]: otherUserData.displayName || 'Utilisateur'
                    }
                };
                
                const docRef = await db.collection('conversations').add(conversationData);
                
                // Ouvrir la nouvelle conversation
                await selectConversation(docRef.id, conversationData);
                
                showNotification('💬 Discussion privée créée !', 'success');
                
            } catch (error) {
                console.error('Erreur création discussion privée:', error);
                showNotification('Erreur lors de la création de la discussion', 'error');
            }
        }


        // Fonction pour afficher le nom correct dans les conversations privées
        function getConversationDisplayName(conversation) {
            if (conversation.type === 'private') {
                // Pour les discussions privées, afficher le nom de l'autre participant
                const otherParticipantId = conversation.participants.find(p => p !== currentUser.uid);
                
                if (conversation.participantNames && conversation.participantNames[otherParticipantId]) {
                    return conversation.participantNames[otherParticipantId];
                } else {
                    // Fallback si participantNames n'existe pas
                    return 'Utilisateur';
                }
            } else {
                // Pour les groupes, afficher le nom personnalisé
                return conversation.name || 'Conversation de groupe';
            }
        }

        // Interface moderne pour la liste des participants
        async function showParticipantsList() {
            if (!currentConversation) return;
            
            try {
                // Récupérer les informations de tous les participants
                const participants = [];
                for (const participantId of currentConversation.participants) {
                    const userDoc = await db.collection('users').doc(participantId).get();
                    if (userDoc.exists) {
                        participants.push({
                            id: participantId,
                            ...userDoc.data()
                        });
                    }
                }
                
                const participantsInterface = document.createElement('div');
                participantsInterface.id = 'participantsInterface';
                participantsInterface.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: var(--bg-secondary);
                    border: 1px solid var(--border);
                    border-radius: 20px;
                    padding: 25px;
                    z-index: 2001;
                    box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                    max-width: 400px;
                    width: 90%;
                    max-height: 70vh;
                    overflow-y: auto;
                `;
                
                participantsInterface.innerHTML = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h3 style="color: var(--primary); margin: 0 0 10px;">👥 Participants</h3>
                        <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                            ${participants.length} participant${participants.length > 1 ? 's' : ''}
                        </p>
                    </div>
                    
                    <div style="display: grid; gap: 10px;">
                        ${participants.map(participant => `
                            <div style="
                                display: flex;
                                align-items: center;
                                padding: 12px;
                                background: var(--bg-tertiary);
                                border-radius: 12px;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='var(--bg-primary)'"
                            onmouseout="this.style.background='var(--bg-tertiary)'">
                                <div style="
                                    width: 40px;
                                    height: 40px;
                                    background: var(--primary);
                                    border-radius: 50%;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    color: white;
                                    font-weight: bold;
                                    margin-right: 12px;
                                ">
                                    ${participant.displayName.charAt(0).toUpperCase()}
                                </div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: var(--text-primary);">
                                        ${participant.displayName}
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">
                                        ID: ${participant.userId || 'N/A'}
                                    </div>
                                </div>
                                ${participant.id === currentUser.uid ? `
                                    <div style="color: var(--primary); font-size: 12px; font-weight: 600;">
                                        Vous
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="closeParticipantsList()" class="btn btn-secondary">
                            ✅ Fermer
                        </button>
                    </div>
                `;
                
                document.body.appendChild(participantsInterface);
                
            } catch (error) {
                console.error('Erreur lors de la récupération des participants:', error);
                showNotification('Erreur lors de la récupération des participants', 'error');
            }
        }

        function closeParticipantsList() {
            const participants = document.getElementById('participantsInterface');
            if (participants) participants.remove();
        }
        // Interface moderne pour les paramètres de conversation
        function showConversationSettings() {
            if (!currentConversation) return;
            
            const settingsInterface = document.createElement('div');
            settingsInterface.id = 'conversationSettings';
            settingsInterface.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 20px;
                padding: 25px;
                z-index: 2000;
                box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                max-width: 500px;
                width: 90%;
                animation: slideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            `;
            
            const isPrivate = currentConversation.type === 'private';
            
            settingsInterface.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <h3 style="color: var(--primary); margin: 0 0 10px;">⚙️ Paramètres de la discussion</h3>
                    <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                        ${isPrivate ? 'Discussion privée' : 'Groupe'}
                    </p>
                </div>
                
                ${!isPrivate ? `
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">Nom du groupe</label>
                        <input type="text" id="conversationNameInput" 
                            value="${currentConversation.name || ''}" 
                            placeholder="Entrez le nom du groupe"
                            style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary);">
                    </div>
                ` : `
                    <div style="text-align: center; margin-bottom: 20px; padding: 15px; background: var(--bg-tertiary); border-radius: 12px;">
                        <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                            Les discussions privées utilisent automatiquement le nom d'utilisateur de votre contact.
                        </p>
                    </div>
                `}
                
                <div style="margin-bottom: 20px;">
                    <button onclick="showParticipantsList()" class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;">
                        👥 Voir les participants (${currentConversation.participants.length})
                    </button>
                    
                    ${!isPrivate ? `
                        <button onclick="showAddParticipantInterface()" class="btn btn-primary" style="width: 100%; margin-bottom: 10px;">
                            ➕ Ajouter des participants
                        </button>
                    ` : ''}
                </div>
                
                <!-- ZONE DE DANGER -->
                <div style="
                    border-top: 1px solid var(--border);
                    padding-top: 20px;
                    margin-top: 20px;
                ">
                    <h4 style="color: var(--danger); margin: 0 0 15px; font-size: 16px;">⚠️ Zone de danger</h4>
                    
                    ${isPrivate ? `
                        <button onclick="confirmDeletePrivateConversation()" 
                                class="btn btn-danger" 
                                style="width: 100%; margin-bottom: 10px; background: var(--danger); color: white;">
                            🗑️ Supprimer la discussion
                        </button>
                        <p style="color: var(--text-secondary); font-size: 12px; margin: 0; text-align: center;">
                            Cette action supprimera définitivement cette discussion privée pour vous uniquement.
                        </p>
                    ` : `
                        <button onclick="confirmLeaveGroup()" 
                                class="btn btn-danger" 
                                style="width: 100%; margin-bottom: 10px; background: var(--danger); color: white;">
                            🚪 Quitter le groupe
                        </button>
                        <p style="color: var(--text-secondary); font-size: 12px; margin: 0; text-align: center;">
                            Vous ne recevrez plus de messages de ce groupe et ne pourrez plus y participer.
                        </p>
                    `}
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    ${!isPrivate ? `
                        <button onclick="saveConversationSettings()" class="btn btn-primary">
                            💾 Sauvegarder
                        </button>
                    ` : ''}
                    <button onclick="closeConversationSettings()" class="btn btn-secondary">
                        ❌ Fermer
                    </button>
                </div>
            `;
            
            // Overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.6);
                z-index: 1999;
            `;
            overlay.onclick = closeConversationSettings;
            
            document.body.appendChild(overlay);
            document.body.appendChild(settingsInterface);
        }


        // Fermer les paramètres de conversation
        function closeConversationSettings() {
            const settings = document.getElementById('conversationSettings');
            if (settings) settings.remove();
            
            const overlay = document.querySelector('div[style*="z-index: 1999"]');
            if (overlay) overlay.remove();
        }


        // Sauvegarder les paramètres de conversation
        async function saveConversationSettings() {
            if (!currentConversation) return;
            
            const nameInput = document.getElementById('conversationNameInput');
            if (nameInput && currentConversation.type !== 'private') {
                const newName = nameInput.value.trim();
                if (newName && newName !== currentConversation.name) {
                    try {
                        await db.collection('conversations').doc(currentConversation.id).update({
                            name: newName
                        });
                        currentConversation.name = newName;
                        updateConversationHeader();
                        showNotification('Nom du groupe mis à jour', 'success');
                    } catch (error) {
                        console.error('Erreur mise à jour nom:', error);
                        showNotification('Erreur lors de la mise à jour', 'error');
                    }
                }
            }
            closeConversationSettings();
        }

        // Interface moderne pour la liste des participants
        async function showParticipantsList() {
            if (!currentConversation) return;
            
            try {
                // Récupérer les informations de tous les participants
                const participants = [];
                for (const participantId of currentConversation.participants) {
                    const userDoc = await db.collection('users').doc(participantId).get();
                    if (userDoc.exists) {
                        participants.push({
                            id: participantId,
                            ...userDoc.data()
                        });
                    }
                }
                
                const participantsInterface = document.createElement('div');
                participantsInterface.id = 'participantsInterface';
                participantsInterface.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: var(--bg-secondary);
                    border: 1px solid var(--border);
                    border-radius: 20px;
                    padding: 25px;
                    z-index: 2001;
                    box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                    max-width: 400px;
                    width: 90%;
                    max-height: 70vh;
                    overflow-y: auto;
                `;
                
                participantsInterface.innerHTML = `
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h3 style="color: var(--primary); margin: 0 0 10px;">👥 Participants</h3>
                        <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                            ${participants.length} participant${participants.length > 1 ? 's' : ''}
                        </p>
                    </div>
                    
                    <div style="display: grid; gap: 10px;">
                        ${participants.map(participant => `
                            <div style="
                                display: flex;
                                align-items: center;
                                padding: 12px;
                                background: var(--bg-tertiary);
                                border-radius: 12px;
                                transition: all 0.3s ease;
                            " onmouseover="this.style.background='var(--bg-primary)'"
                            onmouseout="this.style.background='var(--bg-tertiary)'">
                                <div style="
                                    width: 40px;
                                    height: 40px;
                                    background: var(--primary);
                                    border-radius: 50%;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    color: white;
                                    font-weight: bold;
                                    margin-right: 12px;
                                ">
                                    ${participant.displayName ? participant.displayName.charAt(0).toUpperCase() : 'U'}
                                </div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: var(--text-primary);">
                                        ${participant.displayName || 'Utilisateur'}
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">
                                        ID: ${participant.userId || 'N/A'}
                                    </div>
                                </div>
                                ${participant.id === currentUser.uid ? `
                                    <div style="color: var(--primary); font-size: 12px; font-weight: 600;">
                                        Vous
                                    </div>
                                ` : `
                                    <button onclick="createOrFindPrivateConversation('${participant.id}')" 
                                            style="background: var(--primary); color: white; border: none; padding: 5px 10px; border-radius: 6px; font-size: 11px; cursor: pointer;"
                                            title="Envoyer un message privé">
                                        💬
                                    </button>
                                `}
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="closeParticipantsList()" class="btn btn-secondary">
                            ✅ Fermer
                        </button>
                    </div>
                `;
                
                document.body.appendChild(participantsInterface);
                
            } catch (error) {
                console.error('Erreur lors de la récupération des participants:', error);
                showNotification('Erreur lors de la récupération des participants', 'error');
            }
        }

        // Fermer la liste des participants
        function closeParticipantsList() {
            const participants = document.getElementById('participantsInterface');
            if (participants) participants.remove();
        }

        // Fonction pour mettre à jour l'en-tête de conversation
        function updateConversationHeader() {
            if (!currentConversation) return;
            
            // Utiliser ton ID existant 'chatTitle' au lieu d'IDs inexistants
            const chatTitle = document.getElementById('chatTitle');
            if (chatTitle) {
                chatTitle.textContent = getConversationDisplayName(currentConversation);
            }
            
            // Tu peux ajouter d'autres mises à jour d'interface selon tes besoins
            console.log('En-tête mis à jour pour:', getConversationDisplayName(currentConversation));
        }


        // Fonction pour obtenir le nom d'affichage de la conversation
        function getConversationDisplayName(conversation) {
            if (conversation.type === 'private') {
                // Pour les discussions privées, afficher le nom de l'autre participant
                const otherParticipantId = conversation.participants.find(p => p !== currentUser.uid);
                return conversation.participantNames?.[otherParticipantId] || 'Utilisateur';
            } else {
                // Pour les groupes, afficher le nom personnalisé
                return conversation.name || 'Conversation de groupe';
            }
        }
        // Fonction pour sélectionner une conversation
        async function selectConversation(conversationId, conversationData = null) {
            try {
                // Si on n'a pas les données, les récupérer
                if (!conversationData) {
                    const conversationDoc = await db.collection('conversations').doc(conversationId).get();
                    if (!conversationDoc.exists) {
                        showNotification('Conversation introuvable', 'error');
                        return;
                    }
                    conversationData = conversationDoc.data();
                }
                
                // Mettre à jour la conversation courante
                currentConversation = {
                    id: conversationId,
                    ...conversationData
                };
                updateChatHeader(currentConversation);
                safeSetDisplay('messageInputContainer', 'flex');
                const messageInputContainer = document.getElementById('messageInputContainer');
                if (messageInputContainer) {
                    messageInputContainer.style.visibility = 'visible';
                }
                // CORRECTION : Utiliser tes IDs existants au lieu des manquants
                // document.getElementById('conversationView').style.display = 'block';     ❌
                // document.getElementById('welcomeScreen').style.display = 'none';        ❌
                
                // Utiliser la fonction sécurisée et tes vrais IDs
                safeSetDisplay('messagesContainer', 'block');    // ✅ ID existant
                
                // Mettre à jour l'en-tête de conversation
                updateConversationHeader();
                
                // Charger les messages
                loadMessages(conversationId);
                
                // Surligner la conversation dans la liste
                document.querySelectorAll('.conversation-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                const activeConversation = document.querySelector(`[data-conversation-id="${conversationId}"]`);
                if (activeConversation) {
                    activeConversation.classList.add('active');
                }
                
            } catch (error) {
                console.error('Erreur lors de la sélection de conversation:', error);
                showNotification("Erreur lors de l'ouverture de la conversation", "error");
            }
        }

        // Confirmer la suppression d'une discussion privée
        function confirmDeletePrivateConversation() {
            if (!currentConversation || currentConversation.type !== 'private') return;
            
            const confirmInterface = document.createElement('div');
            confirmInterface.id = 'confirmDeleteInterface';
            confirmInterface.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 2px solid var(--danger);
                border-radius: 20px;
                padding: 25px;
                z-index: 2002;
                box-shadow: 0 25px 50px rgba(239, 68, 68, 0.3);
                max-width: 400px;
                width: 90%;
                text-align: center;
            `;
            
            confirmInterface.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">🗑️</div>
                    <h3 style="color: var(--danger); margin: 0 0 10px;">Supprimer la discussion ?</h3>
                    <p style="color: var(--text-secondary); margin: 0; line-height: 1.5;">
                        Cette action supprimera définitivement cette discussion privée de votre liste.
                        <br><br>
                        <strong>Cette action est irréversible.</strong>
                    </p>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="deletePrivateConversation()" class="btn btn-danger">
                        🗑️ Oui, supprimer
                    </button>
                    <button onclick="closeConfirmDelete()" class="btn btn-secondary">
                        ❌ Annuler
                    </button>
                </div>
            `;
            
            document.body.appendChild(confirmInterface);
        }

        // Supprimer définitivement la discussion privée
        async function deletePrivateConversation() {
            if (!currentConversation) return;
            
            try {
                // Supprimer la conversation et tous ses messages
                const batch = db.batch();
                
                // Supprimer tous les messages
                const messagesSnapshot = await db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .get();
                
                messagesSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                // Supprimer la conversation
                batch.delete(db.collection('conversations').doc(currentConversation.id));
                
                await batch.commit();
                
                showNotification('💔 Discussion privée supprimée', 'success');
                
                // Fermer les interfaces avec vérifications d'existence
                const confirmDelete = document.getElementById('confirmDeleteInterface');
                if (confirmDelete) confirmDelete.remove();
                
                const conversationView = document.getElementById('conversationView');
                if (conversationView) conversationView.style.display = 'none';
                
                const welcomeScreen = document.getElementById('welcomeScreen');
                if (welcomeScreen) welcomeScreen.style.display = 'block';
                
                const settingsInterface = document.getElementById('conversationSettings');
                if (settingsInterface) settingsInterface.remove();
                
                // Supprimer aussi l'overlay s'il existe
                const overlay = document.querySelector('div[style*="z-index: 1999"]');
                if (overlay) overlay.remove();
                
                // Retourner à l'écran d'accueil
                currentConversation = null;
                
                // Actualiser la liste des conversations
                if (typeof loadConversations === 'function') {
                    loadConversations();
                }
                
            } catch (error) {
                console.error('Erreur suppression discussion:', error);
                showNotification('Erreur lors de la suppression', 'error');
            }
        }


        function closeConfirmDelete() {
            const confirm = document.getElementById('confirmDeleteInterface');
            if (confirm) confirm.remove();
        }
        // Confirmer la sortie du groupe
        function confirmLeaveGroup() {
            if (!currentConversation || currentConversation.type === 'private') return;
            
            const confirmInterface = document.createElement('div');
            confirmInterface.id = 'confirmLeaveInterface';
            confirmInterface.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 2px solid var(--warning);
                border-radius: 20px;
                padding: 25px;
                z-index: 2002;
                box-shadow: 0 25px 50px rgba(245, 158, 11, 0.3);
                max-width: 400px;
                width: 90%;
                text-align: center;
            `;
            
            confirmInterface.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">🚪</div>
                    <h3 style="color: var(--warning); margin: 0 0 10px;">Quitter le groupe ?</h3>
                    <p style="color: var(--text-secondary); margin: 0; line-height: 1.5;">
                        Vous allez quitter le groupe "<strong>${currentConversation.name || 'Sans nom'}</strong>".
                        <br><br>
                        Vous ne recevrez plus de messages de ce groupe et ne pourrez plus y participer.
                        <br><br>
                        <strong>Vous pourrez être rajouté(e) plus tard par un membre.</strong>
                    </p>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="leaveGroup()" class="btn" style="background: var(--warning); color: white;">
                        🚪 Oui, quitter
                    </button>
                    <button onclick="closeConfirmLeave()" class="btn btn-secondary">
                        ❌ Rester
                    </button>
                </div>
            `;
            
            document.body.appendChild(confirmInterface);
        }

        // Quitter le groupe
        async function leaveGroup() {
            if (!currentConversation || !currentUser) return;
            
            try {
                // Retirer l'utilisateur de la liste des participants
                const updatedParticipants = currentConversation.participants.filter(
                    participant => participant !== currentUser.uid
                );
                
                if (updatedParticipants.length === 0) {
                    // Si plus personne dans le groupe, le supprimer complètement
                    await deleteEmptyGroup();
                } else {
                    // Mettre à jour la liste des participants
                    await db.collection('conversations').doc(currentConversation.id).update({
                        participants: updatedParticipants
                    });
                    
                    // Envoyer un message système
                    await db.collection('conversations')
                        .doc(currentConversation.id)
                        .collection('messages')
                        .add({
                            type: 'system',
                            text: `${currentUser.displayName || 'Un utilisateur'} a quitté le groupe`,
                            senderId: 'system',
                            timestamp: firebase.firestore.FieldValue.serverTimestamp()
                        });
                }
                
                showNotification('👋 Vous avez quitté le groupe', 'success');
                
                // Fermer les interfaces
                closeConfirmLeave();
                closeConversationSettings();
                
                // Retourner à l'écran d'accueil
                currentConversation = null;
                document.getElementById('conversationView').style.display = 'none';
                document.getElementById('welcomeScreen').style.display = 'block';
                
                // Actualiser la liste des conversations
                loadConversations();
                
            } catch (error) {
                console.error('Erreur en quittant le groupe:', error);
                showNotification('Erreur lors de la sortie du groupe', 'error');
            }
        }

        // Supprimer un groupe vide
        async function deleteEmptyGroup() {
            try {
                const batch = db.batch();
                
                // Supprimer tous les messages
                const messagesSnapshot = await db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .get();
                
                messagesSnapshot.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                // Supprimer la conversation
                batch.delete(db.collection('conversations').doc(currentConversation.id));
                
                await batch.commit();
                
                showNotification('🗑️ Groupe supprimé (plus de participants)', 'info');
                
            } catch (error) {
                console.error('Erreur suppression groupe vide:', error);
            }
        }

        function closeConfirmLeave() {
            const confirm = document.getElementById('confirmLeaveInterface');
            if (confirm) confirm.remove();
        }

        // Afficher le profil utilisateur avec badge admin
        async function showUserProfile(userId) {
            if (!userId) return;
            
            try {
                // Récupérer les données utilisateur
                const userDoc = await db.collection('users').doc(userId).get();
                if (!userDoc.exists) {
                    showNotification('Utilisateur introuvable', 'error');
                    return;
                }
                
                const userData = userDoc.data();
                const userIsAdmin = isAdmin(userId);
                
                // Créer l'interface du profil
                const profileInterface = document.createElement('div');
                profileInterface.id = 'userProfileInterface';
                profileInterface.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: var(--bg-secondary);
                    border: 1px solid var(--border);
                    border-radius: 20px;
                    padding: 25px;
                    z-index: 2000;
                    box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                    max-width: 400px;
                    width: 90%;
                    text-align: center;
                `;
                
                profileInterface.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="
                            width: 80px;
                            height: 80px;
                            background: ${userIsAdmin ? 'linear-gradient(135deg, #ef4444, #dc2626)' : 'var(--primary)'};
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            color: white;
                            font-weight: bold;
                            font-size: 28px;
                            margin: 0 auto 15px;
                            ${userIsAdmin ? 'animation: pulse 2s infinite;' : ''}
                        ">
                            ${userIsAdmin ? '👑' : (userData.displayName ? userData.displayName.charAt(0).toUpperCase() : 'U')}
                        </div>
                        
                        <h3 style="color: var(--text-primary); margin: 0 0 5px; display: flex; align-items: center; justify-content: center;">
                            ${userData.displayName || 'Utilisateur'}
                            ${userIsAdmin ? '<span class="admin-badge">👑 Administrateur</span>' : ''}
                        </h3>
                        
                        <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                            ID: ${userData.userId || 'N/A'}
                        </p>
                        
                        ${userIsAdmin ? `
                            <div style="margin: 15px 0; padding: 12px; background: rgba(239, 68, 68, 0.1); border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.3);">
                                <p style="color: var(--danger); margin: 0; font-size: 13px; font-weight: 600;">
                                    ⚠️ Compte Administrateur
                                </p>
                                <p style="color: var(--text-secondary); margin: 5px 0 0; font-size: 12px;">
                                    Ce compte dispose de privilèges étendus sur la plateforme
                                </p>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        ${userId !== currentUser.uid ? `
                            <button onclick="createOrFindPrivateConversation('${userId}')" class="btn btn-primary">
                                💬 Message privé
                            </button>
                        ` : ''}
                        <button onclick="closeUserProfile()" class="btn btn-secondary">
                            ✅ Fermer
                        </button>
                    </div>
                `;
                
                // Overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.6);
                    z-index: 1999;
                `;
                overlay.onclick = closeUserProfile;
                
                document.body.appendChild(overlay);
                document.body.appendChild(profileInterface);
                
            } catch (error) {
                console.error('Erreur affichage profil:', error);
                showNotification('Erreur lors de l\'affichage du profil', 'error');
            }
        }

        // Fermer le profil utilisateur
        function closeUserProfile() {
            const profile = document.getElementById('userProfileInterface');
            const overlay = document.querySelector('div[style*="z-index: 1999"]');
            
            if (profile) profile.remove();
            if (overlay) overlay.remove();
        }
        // Fonction pour modifier le style en toute sécurité
        function safeSetDisplay(id, displayValue) {
            const element = document.getElementById(id);
            if (element) {
                element.style.display = displayValue;
            } else {
                console.warn(`Élément avec l'ID "${id}" introuvable`);
            }
        }

        // Fonction pour modifier n'importe quelle propriété de style
        function safeSetStyle(id, property, value) {
            const element = document.getElementById(id);
            if (element) {
                element.style[property] = value;
            } else {
                console.warn(`Élément avec l'ID "${id}" introuvable`);
            }
        }
        function initializeApp() {
            safeSetDisplay('authContainer', 'none');
            safeSetDisplay('mainApp', 'block');
            safeSetDisplay('conversationView', 'none');
            safeSetDisplay('welcomeScreen', 'block');
            
            if (typeof loadConversations === 'function') {
                loadConversations();
            }
            
            console.log('Application initialisée pour:', currentUser?.displayName || currentUser?.email);
        }

        // Afficher l'ID utilisateur et le badge admin correctement
        function updateUserDisplay() {
            if (!currentUser) return;
            
            // Afficher l'ID utilisateur
            const userIdDisplay = document.getElementById('userIdDisplay');
            if (userIdDisplay) {
                userIdDisplay.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-family: monospace; background: var(--bg-tertiary); padding: 4px 8px; border-radius: 6px; font-size: 12px; color: white;">
                            ID: ${currentUser.userId || 'N/A'}
                        </span>
                        ${isAdmin(currentUser.uid) ? `
                            <span onclick="openAnnouncementModal()" 
                                style="
                                    background: linear-gradient(135deg, #ef4444, #dc2626);
                                    color: white;
                                    padding: 4px 10px;
                                    border-radius: 12px;
                                    font-size: 13px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    transition: all 0.3s ease;
                                    user-select: none;
                                    position: relative;
                                    overflow: hidden;
                                "
                                onmouseover="
                                    this.style.background='linear-gradient(135deg, #dc2626, #b91c1c)';
                                    this.style.transform='scale(1.05)';
                                    this.style.boxShadow='0 4px 12px rgba(239, 68, 68, 0.4)';
                                "
                                onmouseout="
                                    this.style.background='linear-gradient(135deg, #ef4444, #dc2626)';
                                    this.style.transform='scale(1)';
                                    this.style.boxShadow='none';
                                "
                                title="Cliquer pour faire une annonce générale">
                                📢 Admin
                            </span>
                        ` : ''}
                    </div>
                `;
            }
        }

        // Système de recherche dans les discussions et messages
        let searchTimeout;

        document.getElementById('searchInput').addEventListener('input', function(e) {
            const query = e.target.value.trim();
            
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (query.length >= 2) {
                    performSearch(query);
                } else {
                    hideSearchResults();
                }
            }, 300);
        });

        async function performSearch(query) {
            const results = [];
            const queryLower = query.toLowerCase();
            
            try {
                // Rechercher dans les conversations
                const conversationsSnapshot = await db.collection('conversations')
                    .where('participants', 'array-contains', currentUser.uid)
                    .get();
                
                for (const convDoc of conversationsSnapshot.docs) {
                    const conv = convDoc.data();
                    const convName = getConversationDisplayName({...conv, id: convDoc.id});
                    
                    // Vérifier si le nom de la conversation correspond
                    if (convName.toLowerCase().includes(queryLower)) {
                        results.push({
                            type: 'conversation',
                            id: convDoc.id,
                            name: convName,
                            data: conv
                        });
                    }
                    
                    // Rechercher dans les messages de cette conversation
                    const messagesSnapshot = await db.collection('conversations')
                        .doc(convDoc.id)
                        .collection('messages')
                        .where('senderId', '!=', 'system')
                        .limit(50)
                        .get();
                    
                    for (const msgDoc of messagesSnapshot.docs) {
                        const msg = msgDoc.data();
                        if (msg.text && msg.text.toLowerCase().includes(queryLower)) {
                            // Récupérer le nom de l'expéditeur
                            const senderDoc = await db.collection('users').doc(msg.senderId).get();
                            const senderName = senderDoc.exists ? senderDoc.data().displayName : 'Utilisateur';
                            
                            results.push({
                                type: 'message',
                                conversationId: convDoc.id,
                                conversationName: convName,
                                messageId: msgDoc.id,
                                text: msg.text,
                                sender: senderName,
                                timestamp: msg.timestamp
                            });
                        }
                    }
                }
                
                displaySearchResults(results, query);
                
            } catch (error) {
                console.error('Erreur de recherche:', error);
            }
        }

        function displaySearchResults(results, query) {
            const container = document.getElementById('searchResults');
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div style="padding: 15px; text-align: center; color: var(--text-secondary);">
                        Aucun résultat pour "${query}"
                    </div>
                `;
            } else {
                container.innerHTML = results.slice(0, 10).map(result => {
                    if (result.type === 'conversation') {
                        return `
                            <div onclick="selectConversationFromSearch('${result.id}')" style="
                                padding: 12px 15px;
                                cursor: pointer;
                                border-bottom: 1px solid var(--border);
                                transition: background 0.3s ease;
                            " onmouseover="this.style.background='var(--bg-tertiary)'"
                            onmouseout="this.style.background='transparent'">
                                <div style="font-weight: 600; color: var(--primary);">💬 ${result.name}</div>
                                <div style="font-size: 12px; color: var(--text-secondary);">Discussion</div>
                            </div>
                        `;
                    } else {
                        return `
                            <div onclick="selectConversationFromSearch('${result.conversationId}', '${result.messageId}')" style="
                                padding: 12px 15px;
                                cursor: pointer;
                                border-bottom: 1px solid var(--border);
                                transition: background 0.3s ease;
                            " onmouseover="this.style.background='var(--bg-tertiary)'"
                            onmouseout="this.style.background='transparent'">
                                <div style="font-weight: 600; color: var(--text-primary);">${result.sender}</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin: 2px 0;">
                                    ${highlightQuery(result.text, query)}
                                </div>
                                <div style="font-size: 11px; color: var(--text-secondary);">
                                    Dans: ${result.conversationName}
                                </div>
                            </div>
                        `;
                    }
                }).join('');
            }
            
            container.style.display = 'block';
        }

        function highlightQuery(text, query) {
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<mark style="background: #ffeb3b; padding: 1px 2px; border-radius: 2px;">$1</mark>');
        }

        function hideSearchResults() {
            document.getElementById('searchResults').style.display = 'none';
        }

        async function selectConversationFromSearch(conversationId, messageId = null) {
            hideSearchResults();
            document.getElementById('searchInput').value = '';
            
            // Ouvrir la conversation
            const convDoc = await db.collection('conversations').doc(conversationId).get();
            if (convDoc.exists) {
                await selectConversation(conversationId, convDoc.data());
                
                // Si un message spécifique, le surligner
                if (messageId) {
                    setTimeout(() => {
                        const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                        if (messageElement) {
                            messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            messageElement.style.background = '#ffeb3b';
                            setTimeout(() => {
                                messageElement.style.background = '';
                            }, 3000);
                        }
                    }, 1000);
                }
            }
        }
        // Affichage intelligent de l'écran d'accueil
        function showWelcomeMessage() {
            const container = document.getElementById('messagesContainer');
            if (!container) return;
            
            container.innerHTML = `
                <div style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    height: 100%;
                    text-align: center;
                    padding: 50px;
                ">
                    <div style="font-size: 48px; margin-bottom: 20px;">💬</div>
                    <h2 style="color: var(--text-primary); margin-bottom: 10px;">Bienvenue sur Ulyra !</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 30px;">
                        Ouvrez une discussion pour commencer à chatter
                    </p>
                </div>
            `;
            toggleMessageBar(false);
        }
        // Version complète qui gère aussi les dates
        function formatTime(timestamp) {
            if (!timestamp) return '';
            
            let date;
            
            // Convertir en objet Date selon le type
            if (timestamp.toDate) {
                date = timestamp.toDate(); // Firebase Timestamp
            } else if (timestamp instanceof Date) {
                date = timestamp; // JavaScript Date
            } else {
                return '';
            }
            
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const messageDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            
            // Si c'est aujourd'hui, afficher seulement l'heure
            if (messageDate.getTime() === today.getTime()) {
                return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            }
            
            // Si c'est hier
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            if (messageDate.getTime() === yesterday.getTime()) {
                return 'Hier ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            }
            
            // Pour les autres dates
            const diffDays = Math.floor((today - messageDate) / (1000 * 60 * 60 * 24));
            if (diffDays < 7) {
                return date.toLocaleDateString([], {weekday: 'short'}) + ' ' + 
                    date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            }
            
            // Pour les dates plus anciennes
            return date.toLocaleDateString([], {day: '2-digit', month: '2-digit'}) + ' ' +
                date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }

        // Fonction pour afficher/masquer la barre de messages
        function toggleMessageBar(show = true) {
            const messageInputContainer = document.getElementById('messageInputContainer');
            if (messageInputContainer) {
                if (show) {
                    messageInputContainer.style.display = 'flex';
                    messageInputContainer.style.visibility = 'visible';
                } else {
                    messageInputContainer.style.display = 'none';
                    messageInputContainer.style.visibility = 'hidden';
                }
            }
        }
        // Modal pour créer une discussion privée
        function showPrivateConversationModal() {
            closeNewConversationMenu();
            
            const modal = document.createElement('div');
            modal.id = 'privateConversationModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 20px;
                padding: 25px;
                z-index: 2000;
                box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                max-width: 450px;
                width: 90%;
                animation: modalSlideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            `;
            
            modal.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">💬</div>
                    <h3 style="color: var(--text-primary); margin: 0 0 10px;">Discussion privée</h3>
                    <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                        Entrez l'email ou l'ID de la personne avec qui vous souhaitez discuter
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Email ou ID utilisateur</label>
                    <input type="text" id="privateContactInput" 
                        placeholder="exemple@email.com ou ID_UTILISATEUR"
                        style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); box-sizing: border-box;">
                    <small style="color: var(--text-secondary); font-size: 12px;">
                        Vous pouvez utiliser l'email d'inscription ou l'ID unique de l'utilisateur
                    </small>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="createPrivateConversationFromInput()" class="btn btn-primary">
                        💬 Créer la discussion
                    </button>
                    <button onclick="closePrivateConversationModal()" class="btn btn-secondary">
                        ❌ Annuler
                    </button>
                </div>
            `;
            
            // Overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.6);
                z-index: 1999;
            `;
            overlay.onclick = closePrivateConversationModal;
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            
            setTimeout(() => {
                const input = document.getElementById('privateContactInput');
                if (input) {
                    input.focus();
                    input.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            createPrivateConversationFromInput();
                        }
                    });
                }
            }, 100);
        }

        // Créer la discussion privée depuis l'input
        async function createPrivateConversationFromInput() {
            const input = document.getElementById('privateContactInput').value.trim();
            
            if (!input) {
                showNotification('Veuillez entrer un email ou un ID', 'error');
                return;
            }
            
            try {
                showNotification('Recherche de l\'utilisateur...', 'info');
                
                let targetUser = null;
                
                if (input.includes('@')) {
                    // Recherche par email - ✅ CORRECTION ICI
                    const emailQuery = await db.collection('users').where('email', '==', input).get();
                    if (!emailQuery.empty && emailQuery.docs.length > 0) {
                        const userDoc = emailQuery.docs[0]; // ✅ Accéder au premier document
                        if (typeof userDoc.data === 'function') {
                            targetUser = { id: userDoc.id, ...userDoc.data() };
                        }
                    }
                } else {
                    // Recherche par ID de document d'abord
                    const userDoc = await db.collection('users').doc(input).get();
                    if (userDoc.exists && typeof userDoc.data === 'function') {
                        targetUser = { id: userDoc.id, ...userDoc.data() };
                    } else {
                        // Recherche par champ userId
                        const userIdQuery = await db.collection('users').where('userId', '==', input).get();
                        if (!userIdQuery.empty && userIdQuery.docs.length > 0) {
                            const userIdDoc = userIdQuery.docs[0]; // ✅ Accéder au premier document
                            if (typeof userIdDoc.data === 'function') {
                                targetUser = { id: userIdDoc.id, ...userIdDoc.data() };
                            }
                        }
                    }
                }
                
                if (!targetUser) {
                    showNotification('Utilisateur introuvable avec cet ID/email', 'error');
                    return;
                }
                
                if (targetUser.id === currentUser.uid) {
                    showNotification('Vous ne pouvez pas créer une discussion avec vous-même', 'error');
                    return;
                }
                
                // Vérifier si une discussion privée existe déjà
                const existingConv = await db.collection('conversations')
                    .where('type', '==', 'private')
                    .where('participants', 'array-contains', currentUser.uid)
                    .get();
                
                for (const doc of existingConv.docs) {
                    const conv = doc.data();
                    if (conv.participants.includes(targetUser.id) && conv.participants.length === 2) {
                        showNotification('Une discussion existe déjà avec cette personne', 'info');
                        await selectConversation(doc.id, conv);
                        closePrivateConversationModal();
                        return;
                    }
                }
                
                // Créer la nouvelle discussion
                const conversationData = {
                    participants: [currentUser.uid, targetUser.id],
                    type: 'private',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: '',
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                    participantNames: {
                        [currentUser.uid]: currentUser.displayName || currentUser.email || 'Utilisateur',
                        [targetUser.id]: targetUser.displayName || targetUser.email || 'Utilisateur'
                    }
                };
                
                const docRef = await db.collection('conversations').add(conversationData);
                
                showNotification('💬 Discussion privée créée !', 'success');
                closePrivateConversationModal();
                
                // Ouvrir la nouvelle conversation
                await selectConversation(docRef.id, conversationData);
                
            } catch (error) {
                console.error('Erreur création discussion privée:', error);
                showNotification('Erreur lors de la création', 'error');
            }
        }



        function closePrivateConversationModal() {
            const modal = document.getElementById('privateConversationModal');
            const overlay = document.querySelector('div[style*="z-index: 1999"]');
            
            if (modal) modal.remove();
            if (overlay) overlay.remove();
        }

        // Modal pour créer un groupe
        function showGroupConversationModal() {
            closeNewConversationMenu();
            
            const modal = document.createElement('div');
            modal.id = 'groupConversationModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 20px;
                padding: 25px;
                z-index: 2000;
                box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                animation: modalSlideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            `;
            
            modal.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">👥</div>
                    <h3 style="color: var(--text-primary); margin: 0 0 10px;">Créer un groupe</h3>
                    <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                        Créez un groupe avec jusqu'à 50 participants
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Nom du groupe</label>
                    <input type="text" id="groupNameInput" 
                        placeholder="Nom de votre groupe..."
                        style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); box-sizing: border-box;">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Participants</label>
                    <textarea id="groupParticipantsInput" 
                            placeholder="Entrez les emails ou IDs des participants (un par ligne)&#10;exemple@email.com&#10;ID_UTILISATEUR&#10;autre@email.com"
                            rows="6"
                            style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); resize: vertical; font-family: monospace; box-sizing: border-box;"></textarea>
                    <small style="color: var(--text-secondary); font-size: 12px;">
                        <span id="participantCount">0</span>/50 participants • Un email ou ID par ligne
                    </small>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="createGroupConversationFromInput()" class="btn btn-primary">
                        👥 Créer le groupe
                    </button>
                    <button onclick="closeGroupConversationModal()" class="btn btn-secondary">
                        ❌ Annuler
                    </button>
                </div>
            `;
            
            // Overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.6);
                z-index: 1999;
            `;
            overlay.onclick = closeGroupConversationModal;
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            
            // Compteur de participants en temps réel
            document.getElementById('groupParticipantsInput').addEventListener('input', function() {
                const lines = this.value.trim().split('\n').filter(line => line.trim());
                document.getElementById('participantCount').textContent = lines.length;
            });
            
            // Focus sur le nom
            setTimeout(() => {
                document.getElementById('groupNameInput').focus();
            }, 100);
        }

        // Créer le groupe depuis les inputs
        async function createGroupConversationFromInput() {
            const groupName = document.getElementById('groupNameInput').value.trim();
            const participantsText = document.getElementById('groupParticipantsInput').value.trim();
            
            if (!groupName) {
                showNotification('Veuillez entrer un nom de groupe', 'error');
                return;
            }
            
            if (!participantsText) {
                showNotification('Veuillez ajouter des participants', 'error');
                return;
            }
            
            const participantInputs = participantsText.split('\n').map(line => line.trim()).filter(line => line);
            
            if (participantInputs.length === 0) {
                showNotification('Veuillez ajouter au moins un participant', 'error');
                return;
            }
            
            if (participantInputs.length > 50) {
                showNotification('Maximum 50 participants autorisés', 'error');
                return;
            }
            
            try {
                showNotification('Recherche des participants...', 'info');
                
                const validParticipants = [];
                const participantNames = {
                    [currentUser.uid]: currentUser.displayName || currentUser.email || 'Utilisateur'
                };
                
                for (const input of participantInputs) {
                    let targetUser = null;
                    
                    console.log('🔍 Recherche participant:', input);
                    
                    if (input.includes('@')) {
                        // Recherche par email
                        const emailQuery = await db.collection('users').where('email', '==', input).get();
                        console.log('📧 Query email:', emailQuery);
                        
                        if (!emailQuery.empty && emailQuery.docs && emailQuery.docs.length > 0) {
                            const userDoc = emailQuery.docs[0];
                            console.log('📄 UserDoc trouvé:', userDoc);
                            
                            if (userDoc && typeof userDoc.data === 'function') {
                                targetUser = { id: userDoc.id, ...userDoc.data() };
                                console.log('✅ Utilisateur email trouvé:', targetUser);
                            } else {
                                console.error('❌ userDoc.data() n\'est pas une fonction pour email', userDoc);
                            }
                        }
                    } else {
                        // Recherche par ID de document d'abord
                        const userDoc = await db.collection('users').doc(input).get();
                        console.log('📄 Doc search:', userDoc);
                        
                        if (userDoc && userDoc.exists && typeof userDoc.data === 'function') {
                            targetUser = { id: userDoc.id, ...userDoc.data() };
                            console.log('✅ Utilisateur doc trouvé:', targetUser);
                        } else {
                            // Recherche par champ userId
                            const userIdQuery = await db.collection('users').where('userId', '==', input).get();
                            console.log('🆔 Query userId:', userIdQuery);
                            
                            if (!userIdQuery.empty && userIdQuery.docs && userIdQuery.docs.length > 0) {
                                const userIdDoc = userIdQuery.docs[0];
                                console.log('📄 UserIdDoc trouvé:', userIdDoc);
                                
                                if (userIdDoc && typeof userIdDoc.data === 'function') {
                                    targetUser = { id: userIdDoc.id, ...userIdDoc.data() };
                                    console.log('✅ Utilisateur userId trouvé:', targetUser);
                                } else {
                                    console.error('❌ userIdDoc.data() n\'est pas une fonction pour userId', userIdDoc);
                                }
                            }
                        }
                    }
                    
                    // Ajouter l'utilisateur s'il est valide
                    if (targetUser && targetUser.id && targetUser.id !== currentUser.uid) {
                        if (!validParticipants.includes(targetUser.id)) {
                            validParticipants.push(targetUser.id);
                            participantNames[targetUser.id] = targetUser.displayName || targetUser.email || 'Utilisateur';
                            console.log('➕ Participant ajouté:', targetUser.displayName || targetUser.email);
                        }
                    } else {
                        console.log('❌ Participant invalide ou inexistant:', input);
                    }
                }
                
                console.log('👥 Total participants valides:', validParticipants);
                
                if (validParticipants.length === 0) {
                    showNotification('Aucun participant valide trouvé', 'error');
                    return;
                }
                
                // Créer le groupe
                const conversationData = {
                    name: groupName,
                    participants: [currentUser.uid, ...validParticipants],
                    type: 'group',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: '',
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                    participantNames: participantNames,
                    createdBy: currentUser.uid
                };
                
                console.log('🏗️ Création groupe:', conversationData);
                
                const docRef = await db.collection('conversations').add(conversationData);
                
                // Message système de création
                await db.collection('conversations')
                    .doc(docRef.id)
                    .collection('messages')
                    .add({
                        type: 'system',
                        text: `Groupe "${groupName}" créé par ${currentUser.displayName || 'Un utilisateur'}`,
                        senderId: 'system',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                
                showNotification(`👥 Groupe "${groupName}" créé avec ${validParticipants.length + 1} membres !`, 'success');
                closeGroupConversationModal();
                
                // Ouvrir le nouveau groupe
                await selectConversation(docRef.id, conversationData);
                
            } catch (error) {
                console.error('Erreur création groupe:', error);
                showNotification('Erreur lors de la création du groupe', 'error');
            }
        }



        function closeGroupConversationModal() {
            const modal = document.getElementById('groupConversationModal');
            const overlay = document.querySelector('div[style*="z-index: 1999"]');
            
            if (modal) modal.remove();
            if (overlay) overlay.remove();
        }
        // NOUVELLE fonction - celle à garder
        function openNewConversation(event) {
            // Supprimer un éventuel menu existant  
            const existingMenu = document.getElementById('newConversationMenu');
            if (existingMenu) existingMenu.remove();
            
            // Créer le menu déroulant
            const menu = document.createElement('div');
            menu.id = 'newConversationMenu';
            menu.style.cssText = `
                position: fixed;
                top: ${event.target.getBoundingClientRect().bottom + 5}px;
                left: ${event.target.getBoundingClientRect().left}px;
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 12px;
                box-shadow: 0 8px 25px rgba(0,0,0,0.15);
                z-index: 2000;
                overflow: hidden;
                min-width: 200px;
            `;
            
            menu.innerHTML = `
                <div onclick="showPrivateConversationModal(); closeNewConversationMenu();" style="
                    padding: 12px 16px;
                    cursor: pointer;
                    transition: background 0.2s;
                    border-bottom: 1px solid var(--border);
                " onmouseover="this.style.background='var(--bg-tertiary)'" 
                onmouseout="this.style.background='transparent'">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 18px;">💬</span>
                        <div>
                            <div style="font-weight: 600; color: var(--text-primary);">Discussion privée</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">Chatter avec une personne</div>
                        </div>
                    </div>
                </div>
                
                <div onclick="showGroupConversationModal(); closeNewConversationMenu();" style="
                    padding: 12px 16px;
                    cursor: pointer;
                    transition: background 0.2s;
                " onmouseover="this.style.background='var(--bg-tertiary)'" 
                onmouseout="this.style.background='transparent'">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 18px;">👥</span>
                        <div>
                            <div style="font-weight: 600; color: var(--text-primary);">Créer un groupe</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">Jusqu'à 50 participants</div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(menu);
            
            // Fermer le menu en cliquant ailleurs
            setTimeout(() => {
                document.addEventListener('click', function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                });
            }, 100);
        }

        function closeNewConversationMenu() {
            const menu = document.getElementById('newConversationMenu');
            if (menu) menu.remove();
        }
        function updateChatHeader(conversationData) {
            const chatHeader = document.getElementById('chatHeader');
            const chatTitle = document.getElementById('chatTitle');
            const chatActions = document.querySelector('.chat-actions');
            
            if (conversationData.type === 'private') {
                // Discussion privée
                const otherParticipant = conversationData.participants.find(p => p !== currentUser.uid);
                const otherParticipantName = conversationData.participantNames?.[otherParticipant] || 'Utilisateur';
                
                chatTitle.textContent = otherParticipantName;
                chatActions.innerHTML = `
                    <button class="delete-conversation-btn" onclick="deletePrivateConversation('${currentConversation.id}')" title="Supprimer la discussion">
                        🗑️ Supprimer
                    </button>
                `;
            } else if (conversationData.type === 'group') {
                // Groupe
                chatTitle.textContent = conversationData.name || 'Groupe';
                chatActions.innerHTML = `
                    <button class="btn btn-secondary btn-small" onclick="openGroupSettings('${currentConversation.id}')" title="Paramètres du groupe">
                        ⚙️ Paramètres
                    </button>
                `;
            }
            
            chatHeader.style.display = 'flex';
        }

        async function deletePrivateConversation(conversationId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer cette discussion ? Elle sera masquée jusqu\'à ce que la personne vous envoie un nouveau message.')) {
                return;
            }
            
            try {
                // Marquer la conversation comme supprimée pour l'utilisateur actuel
                await db.collection('conversations').doc(conversationId).update({
                    [`deletedFor.${currentUser.uid}`]: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                showNotification('Discussion supprimée', 'success');
                
                // Fermer la conversation et revenir à l'accueil
                currentConversation = null;
                showWelcomeMessage();
                
                // Masquer le header et la barre de messages
                safeSetDisplay('chatHeader', 'none');
                safeSetDisplay('messageInputContainer', 'none');
                
                // Recharger la liste des conversations
                await loadConversations();
                
            } catch (error) {
                console.error('Erreur suppression discussion:', error);
                showNotification('Erreur lors de la suppression', 'error');
            }
        }
        function openGroupSettings(conversationId) {
            const modal = document.createElement('div');
            modal.id = 'groupSettingsModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 20px;
                padding: 25px;
                z-index: 2000;
                box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                max-width: 500px;
                width: 90%;
                max-height: 70vh;
                overflow-y: auto;
                animation: modalSlideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            `;
            
            // Récupérer les données du groupe
            const groupData = currentConversation;
            const isCreator = groupData.createdBy === currentUser.uid;
            
            modal.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">👥</div>
                    <h3 style="color: var(--text-primary); margin: 0 0 10px;">${groupData.name || 'Groupe'}</h3>
                    <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                        ${groupData.participants?.length || 0} participants
                    </p>
                </div>
                
                <div style="margin-bottom: 25px;">
                    <h4 style="color: var(--text-primary); margin-bottom: 15px; font-size: 16px;">👤 Participants</h4>
                    <div id="participantsList" style="max-height: 200px; overflow-y: auto;">
                        <!-- Liste des participants sera remplie par JS -->
                    </div>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    ${isCreator ? `
                        <button onclick="addParticipants('${conversationId}')" class="btn btn-secondary" style="width: 100%;">
                            ➕ Ajouter des participants
                        </button>
                        <button onclick="deleteGroup('${conversationId}')" class="btn" style="width: 100%; background: #ef4444; color: white;">
                            🗑️ Supprimer le groupe
                        </button>
                    ` : ''}
                    <button onclick="leaveGroup('${conversationId}')" class="btn" style="width: 100%; background: #f59e0b; color: white;">
                        🚪 Quitter le groupe
                    </button>
                    <button onclick="closeGroupSettings()" class="btn btn-secondary" style="width: 100%;">
                        ❌ Fermer
                    </button>
                </div>
            `;
            
            // Overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.6);
                z-index: 1999;
            `;
            overlay.onclick = closeGroupSettings;
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            
            // Charger la liste des participants
            loadParticipantsList(conversationId);
        }

        async function loadParticipantsList(conversationId) {
            const participantsList = document.getElementById('participantsList');
            const groupData = currentConversation;
            
            participantsList.innerHTML = '<div style="text-align: center; color: var(--text-secondary);">Chargement...</div>';
            
            try {
                const participantsHtml = [];
                
                for (const participantId of groupData.participants || []) {
                    const participantName = groupData.participantNames?.[participantId] || 'Utilisateur';
                    const isCreator = participantId === groupData.createdBy;
                    const isCurrentUser = participantId === currentUser.uid;
                    
                    participantsHtml.push(`
                        <div style="
                            display: flex; 
                            align-items: center; 
                            justify-content: space-between;
                            padding: 10px 0;
                            border-bottom: 1px solid var(--border);
                        ">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 20px;">👤</span>
                                <div>
                                    <div style="font-weight: 600; color: var(--text-primary);">
                                        ${participantName} ${isCurrentUser ? '(Vous)' : ''}
                                    </div>
                                    ${isCreator ? '<div style="font-size: 12px; color: var(--text-secondary);">👑 Créateur</div>' : ''}
                                </div>
                            </div>
                            ${groupData.createdBy === currentUser.uid && !isCurrentUser ? `
                                <button onclick="removeParticipant('${conversationId}', '${participantId}')" 
                                        style="background: #ef4444; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; cursor: pointer;">
                                    Retirer
                                </button>
                            ` : ''}
                        </div>
                    `);
                }
                
                participantsList.innerHTML = participantsHtml.join('');
                
            } catch (error) {
                console.error('Erreur chargement participants:', error);
                participantsList.innerHTML = '<div style="color: #ef4444;">Erreur de chargement</div>';
            }
        }
        async function leaveGroup(conversationId) {
            if (!confirm('Êtes-vous sûr de vouloir quitter ce groupe ?')) {
                return;
            }
            
            try {
                const groupData = currentConversation;
                
                // Retirer l'utilisateur de la liste des participants
                const updatedParticipants = groupData.participants.filter(p => p !== currentUser.uid);
                const updatedParticipantNames = { ...groupData.participantNames };
                delete updatedParticipantNames[currentUser.uid];
                
                await db.collection('conversations').doc(conversationId).update({
                    participants: updatedParticipants,
                    participantNames: updatedParticipantNames
                });
                
                // Message système
                await db.collection('conversations')
                    .doc(conversationId)
                    .collection('messages')
                    .add({
                        type: 'system',
                        text: `${currentUser.displayName || 'Un utilisateur'} a quitté le groupe`,
                        senderId: 'system',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                
                showNotification('Vous avez quitté le groupe', 'success');
                closeGroupSettings();
                
                // Retourner à l'accueil
                currentConversation = null;
                showWelcomeMessage();
                safeSetDisplay('chatHeader', 'none');
                safeSetDisplay('messageInputContainer', 'none');
                
                await loadConversations();
                
            } catch (error) {
                console.error('Erreur quitter groupe:', error);
                showNotification('Erreur lors de la sortie du groupe', 'error');
            }
        }

        async function deleteGroup(conversationId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer définitivement ce groupe ? Cette action est irréversible !')) {
                return;
            }
            
            try {
                // Supprimer tous les messages
                const messagesRef = db.collection('conversations').doc(conversationId).collection('messages');
                const messagesSnapshot = await messagesRef.get();
                
                const batch = db.batch();
                messagesSnapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
                
                // Supprimer la conversation
                await db.collection('conversations').doc(conversationId).delete();
                
                showNotification('Groupe supprimé', 'success');
                closeGroupSettings();
                
                // Retourner à l'accueil
                currentConversation = null;
                showWelcomeMessage();
                safeSetDisplay('chatHeader', 'none');
                safeSetDisplay('messageInputContainer', 'none');
                
                await loadConversations();
                
            } catch (error) {
                console.error('Erreur suppression groupe:', error);
                showNotification('Erreur lors de la suppression', 'error');
            }
        }

        function closeGroupSettings() {
            const modal = document.getElementById('groupSettingsModal');
            const overlay = document.querySelector('div[style*="z-index: 1999"]');
            
            if (modal) modal.remove();
            if (overlay) overlay.remove();
        }
        function updateChatHeader(conversationData) {
            const chatHeader = document.getElementById('chatHeader');
            const chatTitle = document.getElementById('chatTitle');
            const chatActions = document.querySelector('.chat-actions');
            
            if (!chatActions) {
                console.error('Le container .chat-actions est introuvable');
                return;
            }
            
            if (conversationData.type === 'private') {
                // Discussion privée - Bouton Supprimer
                const otherParticipant = conversationData.participants.find(p => p !== currentUser.uid);
                const otherParticipantName = conversationData.participantNames?.[otherParticipant] || 'Utilisateur';
                
                chatTitle.textContent = otherParticipantName;
                chatActions.innerHTML = `
                    <button class="delete-conversation-btn" onclick="deletePrivateConversation('${currentConversation.id}')" title="Supprimer la discussion">
                        🗑️ Supprimer
                    </button>
                `;
            } else if (conversationData.type === 'group') {
                // Groupe - Bouton Paramètres
                chatTitle.textContent = conversationData.name || 'Groupe';
                chatActions.innerHTML = `
                    <button class="btn btn-secondary btn-small" onclick="openGroupSettings('${currentConversation.id}')" title="Paramètres du groupe">
                        ⚙️ Paramètres
                    </button>
                `;
            }
            
            chatHeader.style.display = 'flex';
        }
        function addParticipants(conversationId) {
            const modal = document.createElement('div');
            modal.id = 'addParticipantsModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 20px;
                padding: 25px;
                z-index: 2100;
                box-shadow: 0 25px 50px rgba(0,0,0,0.4);
                max-width: 450px;
                width: 90%;
                animation: modalSlideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            `;
            
            modal.innerHTML = `
                <div style="text-align: center; margin-bottom: 25px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">➕</div>
                    <h3 style="color: var(--text-primary); margin: 0 0 10px;">Ajouter des participants</h3>
                    <p style="color: var(--text-secondary); margin: 0; font-size: 14px;">
                        Entrez les emails ou IDs des personnes à ajouter au groupe
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600;">Participants à ajouter</label>
                    <textarea id="newParticipantsInput" 
                            placeholder="Entrez les emails ou IDs (un par ligne)&#10;exemple@email.com&#10;ID_UTILISATEUR"
                            rows="4"
                            style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); resize: vertical; font-family: monospace; box-sizing: border-box;"></textarea>
                    <small style="color: var(--text-secondary); font-size: 12px;">
                        Un email ou ID par ligne
                    </small>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button onclick="confirmAddParticipants('${conversationId}')" class="btn btn-primary">
                        ➕ Ajouter
                    </button>
                    <button onclick="closeAddParticipantsModal()" class="btn btn-secondary">
                        ❌ Annuler
                    </button>
                </div>
            `;
            
            // Overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.6);
                z-index: 2099;
            `;
            overlay.onclick = closeAddParticipantsModal;
            
            document.body.appendChild(overlay);
            document.body.appendChild(modal);
            
            // Focus sur le textarea
            setTimeout(() => {
                document.getElementById('newParticipantsInput').focus();
            }, 100);
        }

        async function confirmAddParticipants(conversationId) {
            const participantsText = document.getElementById('newParticipantsInput').value.trim();
            
            if (!participantsText) {
                showNotification('Veuillez ajouter au moins un participant', 'error');
                return;
            }
            
            const participantInputs = participantsText.split('\n').map(line => line.trim()).filter(line => line);
            
            try {
                showNotification('Recherche des participants...', 'info');
                
                const groupData = currentConversation;
                const validParticipants = [];
                const newParticipantNames = { ...groupData.participantNames };
                
                for (const input of participantInputs) {
                    let targetUser = null;
                    
                    if (input.includes('@')) {
                        // Recherche par email
                        const emailQuery = await db.collection('users').where('email', '==', input).get();
                        if (!emailQuery.empty && emailQuery.docs.length > 0) {
                            const userDoc = emailQuery.docs[0];
                            if (typeof userDoc.data === 'function') {
                                targetUser = { id: userDoc.id, ...userDoc.data() };
                            }
                        }
                    } else {
                        // Recherche par ID de document d'abord
                        const userDoc = await db.collection('users').doc(input).get();
                        if (userDoc.exists && typeof userDoc.data === 'function') {
                            targetUser = { id: userDoc.id, ...userDoc.data() };
                        } else {
                            // Recherche par champ userId
                            const userIdQuery = await db.collection('users').where('userId', '==', input).get();
                            if (!userIdQuery.empty && userIdQuery.docs.length > 0) {
                                const userIdDoc = userIdQuery.docs[0];
                                if (typeof userIdDoc.data === 'function') {
                                    targetUser = { id: userIdDoc.id, ...userIdDoc.data() };
                                }
                            }
                        }
                    }
                    
                    // Ajouter l'utilisateur s'il est valide et pas déjà dans le groupe
                    if (targetUser && targetUser.id && !groupData.participants.includes(targetUser.id)) {
                        validParticipants.push(targetUser.id);
                        newParticipantNames[targetUser.id] = targetUser.displayName || targetUser.email || 'Utilisateur';
                    }
                }
                
                if (validParticipants.length === 0) {
                    showNotification('Aucun nouveau participant valide trouvé', 'error');
                    return;
                }
                
                // Mettre à jour le groupe
                const updatedParticipants = [...groupData.participants, ...validParticipants];
                
                if (updatedParticipants.length > 50) {
                    showNotification('Maximum 50 participants autorisés dans un groupe', 'error');
                    return;
                }
                
                await db.collection('conversations').doc(conversationId).update({
                    participants: updatedParticipants,
                    participantNames: newParticipantNames
                });
                
                // Message système
                await db.collection('conversations')
                    .doc(conversationId)
                    .collection('messages')
                    .add({
                        type: 'system',
                        text: `${validParticipants.length} nouveau(x) participant(s) ajouté(s) par ${currentUser.displayName || 'Un utilisateur'}`,
                        senderId: 'system',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                
                showNotification(`${validParticipants.length} participant(s) ajouté(s) !`, 'success');
                closeAddParticipantsModal();
                
                // Recharger les paramètres du groupe
                closeGroupSettings();
                setTimeout(() => openGroupSettings(conversationId), 100);
                
            } catch (error) {
                console.error('Erreur ajout participants:', error);
                showNotification('Erreur lors de l\'ajout', 'error');
            }
        }

        function closeAddParticipantsModal() {
            const modal = document.getElementById('addParticipantsModal');
            const overlay = document.querySelector('div[style*="z-index: 2099"]');
            
            if (modal) modal.remove();
            if (overlay) overlay.remove();
        }
        async function removeParticipant(conversationId, participantId) {
            const groupData = currentConversation;
            const participantName = groupData.participantNames?.[participantId] || 'Utilisateur';
            
            if (!confirm(`Êtes-vous sûr de vouloir retirer ${participantName} du groupe ?`)) {
                return;
            }
            
            try {
                // Retirer le participant
                const updatedParticipants = groupData.participants.filter(p => p !== participantId);
                const updatedParticipantNames = { ...groupData.participantNames };
                delete updatedParticipantNames[participantId];
                
                await db.collection('conversations').doc(conversationId).update({
                    participants: updatedParticipants,
                    participantNames: updatedParticipantNames
                });
                
                // Message système
                await db.collection('conversations')
                    .doc(conversationId)
                    .collection('messages')
                    .add({
                        type: 'system',
                        text: `${participantName} a été retiré(e) du groupe par ${currentUser.displayName || 'Un utilisateur'}`,
                        senderId: 'system',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                
                showNotification(`${participantName} a été retiré(e) du groupe`, 'success');
                
                // Recharger les paramètres du groupe
                closeGroupSettings();
                setTimeout(() => openGroupSettings(conversationId), 100);
                
            } catch (error) {
                console.error('Erreur retirer participant:', error);
                showNotification('Erreur lors du retrait', 'error');
            }
        }
        async function leaveGroup(conversationId) {
            if (!confirm('Êtes-vous sûr de vouloir quitter ce groupe ?')) {
                return;
            }
            
            try {
                const groupData = currentConversation;
                
                // Retirer l'utilisateur de la liste des participants
                const updatedParticipants = groupData.participants.filter(p => p !== currentUser.uid);
                const updatedParticipantNames = { ...groupData.participantNames };
                delete updatedParticipantNames[currentUser.uid];
                
                await db.collection('conversations').doc(conversationId).update({
                    participants: updatedParticipants,
                    participantNames: updatedParticipantNames
                });
                
                // Message système
                await db.collection('conversations')
                    .doc(conversationId)
                    .collection('messages')
                    .add({
                        type: 'system',
                        text: `${currentUser.displayName || 'Un utilisateur'} a quitté le groupe`,
                        senderId: 'system',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                
                showNotification('Vous avez quitté le groupe', 'success');
                closeGroupSettings();
                
                // Retourner à l'accueil
                currentConversation = null;
                showWelcomeMessage();
                safeSetDisplay('chatHeader', 'none');
                safeSetDisplay('messageInputContainer', 'none');
                
            } catch (error) {
                console.error('Erreur quitter groupe:', error);
                showNotification('Erreur lors de la sortie du groupe', 'error');
            }
        }

        async function deleteGroup(conversationId) {
            if (!confirm('Êtes-vous sûr de vouloir supprimer définitivement ce groupe ? Cette action est irréversible !')) {
                return;
            }
            
            try {
                // Supprimer tous les messages
                const messagesRef = db.collection('conversations').doc(conversationId).collection('messages');
                const messagesSnapshot = await messagesRef.get();
                
                const batch = db.batch();
                messagesSnapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
                
                // Supprimer la conversation
                await db.collection('conversations').doc(conversationId).delete();
                
                showNotification('Groupe supprimé', 'success');
                closeGroupSettings();
                
                // Retourner à l'accueil
                currentConversation = null;
                showWelcomeMessage();
                safeSetDisplay('chatHeader', 'none');
                safeSetDisplay('messageInputContainer', 'none');
                
            } catch (error) {
                console.error('Erreur suppression groupe:', error);
                showNotification('Erreur lors de la suppression', 'error');
            }
        }
        document.addEventListener('DOMContentLoaded', function() {
            const cancelBtn = document.getElementById('cancelReplyBtn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('🚫 Bouton annuler cliqué via addEventListener');
                    cancelReply();
                });
            }
        });
        function getMessageContentById(messageId) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageElement) return '(message introuvable)';
            
            // Chercher l'élément contenant le texte
            const textElement = messageElement.querySelector('.message-text') || 
                            messageElement.querySelector('[class*="text"]') ||
                            messageElement;
            
            let content = (textElement.textContent || textElement.innerText || '').trim();
            
            // Nettoyer le contenu
            content = content
                .replace(/↳[^\n]*/g, '') // Réponses
                .replace(/[✏️🗑️⚙️]/g, '') // Icônes
                .replace(/\d{2}:\d{2}:\d{2}/g, '') // Heures
                .trim();
            
            return content || '(contenu vide)';
        }
        async function getOriginalMessageContent(messageId) {
            try {
                const messageRef = db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .doc(messageId);
                
                const messageDoc = await messageRef.get();
                
                if (messageDoc.exists) {
                    const data = messageDoc.data();
                    return data.text || '(contenu vide)';
                } else {
                    return '(message introuvable)';
                }
            } catch (error) {
                console.error('Erreur récupération message original:', error);
                return '(erreur récupération)';
            }
        }
        async function displayMessage(message) {
            let messageHTML = '';
            
            // ✅ Support des deux formats de réponse
            let replyToData = null;
            
            if (message.replyTo) {
                if (typeof message.replyTo === 'string') {
                    // ✅ Ancien format (juste l'ID)
                    replyToData = {
                        messageId: message.replyTo,
                        author: 'Utilisateur',
                        content: await getOriginalMessageContent(message.replyTo)
                    };
                } else if (message.replyTo.messageId) {
                    // ✅ Nouveau format (objet complet)
                    replyToData = message.replyTo;
                    // Utiliser le cache ou récupérer depuis Firestore si pas de contenu
                    if (!replyToData.content && messageContentCache[replyToData.messageId]) {
                        replyToData.content = messageContentCache[replyToData.messageId];
                    } else if (!replyToData.content) {
                        replyToData.content = await getOriginalMessageContent(replyToData.messageId);
                        messageContentCache[replyToData.messageId] = replyToData.content;
                    }
                }
            }
            
            // ✅ Afficher la bulle de réponse si on a les données
            if (replyToData) {
                messageHTML += `
                    <div class="reply-bubble" onclick="scrollToMessage('${replyToData.messageId}')" 
                        style="cursor: pointer; transition: all 0.3s ease; background: var(--bg-tertiary); border-left: 3px solid var(--primary); margin-bottom: 8px; padding: 8px 12px; border-radius: 8px; font-size: 13px; opacity: 0.8;"
                        onmouseover="this.style.background='var(--bg-secondary)'"
                        onmouseout="this.style.background='var(--bg-tertiary)'">
                        <div style="color: var(--primary); font-weight: 600; font-size: 11px; margin-bottom: 2px;">
                            ↳ Réponse à ${replyToData.author}
                        </div>
                        <div style="color: var(--text-secondary); line-height: 1.3;">
                            ${replyToData.content}
                        </div>
                    </div>
                `;
            }
            
            messageHTML += `<div class="message-text">${message.text}</div>`;
            return messageHTML;
        }
        // Compteur caractères et activation du bouton
        document.getElementById('feedbackText').oninput = function() {
            const txt = this.value;
            const count = document.getElementById('charCount');
            const btn = document.getElementById('sendFeedbackBtn');
            count.textContent = txt.length + '/50 caractères minimum';
            if (txt.length >= 50) {
                btn.disabled = false;
                btn.style.cursor = 'pointer';
                btn.style.background = 'var(--primary)';
            } else {
                btn.disabled = true;
                btn.style.cursor = 'not-allowed';
                btn.style.background = '';
            }
        };
        async function sendFeedback() {
            const txt = document.getElementById('feedbackText').value.trim();
            if (txt.length < 50) {
                showNotification('Merci de détailler au moins 50 caractères !', 'error');
                return;
            }

            try {
                showNotification('📤 Envoi du feedback...', 'info');
                
                const now = new Date();
                const feedbackId = `feedback_${Date.now()}`;
                
                const feedback = {
                    id: feedbackId,
                    userId: currentUser.uid,
                    userName: currentUser.displayName || "Utilisateur",
                    userEmail: currentUser.email,
                    content: txt,
                    sentAt: now.toISOString(),
                    status: 'En attente'
                };

                // Utiliser ton système ADMIN_IDS
                for (const adminId of ADMIN_IDS) {
                    // Créer ou récupérer la conversation feedback pour cet admin
                    const feedbackConvRef = db.collection('conversations').doc(`feedback_${adminId}`);
                    const feedbackConv = await feedbackConvRef.get();

                    // Créer la conversation si elle n'existe pas
                    if (!feedbackConv.exists) {
                        await feedbackConvRef.set({
                            participants: [adminId, 'system'],
                            type: 'system_feedback',
                            name: '📋 Feedback Système',
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            lastMessage: '',
                            lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                            participantNames: {
                                [adminId]: 'Admin',
                                system: 'Système Ulyra'
                            }
                        });
                    }

                    // Ajouter le message de feedback
                    const messageContent = `📋 **NOUVEAU FEEDBACK**

        **De:** ${feedback.userName} (${feedback.userEmail})
        **Date:** ${now.toLocaleString('fr-FR')}
        **ID:** ${feedbackId}

        **Message:**
        ${txt}`;

                    await feedbackConvRef.collection('messages').add({
                        type: 'system_feedback',
                        senderId: 'system',
                        senderName: 'Système Ulyra',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        feedback: feedback,
                        text: messageContent,
                        actions: {
                            available: ['Accepter', 'En attente', 'Refuser', 'Archiver', 'Répondre'],
                            status: 'En attente'
                        }
                    });

                    // Mettre à jour la dernière activité
                    await feedbackConvRef.update({
                        lastMessage: `Nouveau feedback de ${feedback.userName}`,
                        lastMessageTime: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }

                showNotification('✅ Feedback envoyé aux administrateurs !', 'success');
                
                // Réinitialiser le formulaire
                document.getElementById('feedbackText').value = "";
                document.getElementById('charCount').textContent = "0/50 caractères minimum";
                document.getElementById('sendFeedbackBtn').disabled = true;
                document.getElementById('sendFeedbackBtn').style.background = 'var(--bg-secondary)';
                document.getElementById('sendFeedbackBtn').style.color = 'var(--text-secondary)';
                document.getElementById('sendFeedbackBtn').style.cursor = 'not-allowed';
                
            } catch (error) {
                console.error('Erreur envoi feedback:', error);
                showNotification('Erreur lors de l\'envoi du feedback', 'error');
            }
        }
        function addFeedbackActions(message, messageElement) {
            console.log('🔍 addFeedbackActions appelée avec message:', message);
            
            if (!message.feedback) {
                console.error('❌ Pas de feedback dans le message');
                return;
            }
            
            // Utiliser l'ID du message DOM (passé en paramètre de createMessageElement)
            const realMessageId = messageElement.dataset.messageId || message.id;
            
            console.log('🔍 ID du message utilisé:', realMessageId);
            
            if (!realMessageId) {
                console.error('❌ Impossible de trouver l\'ID du message');
                return;
            }
            
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'feedback-actions';
            actionsDiv.style.cssText = `
                margin-top: 12px;
                padding: 12px;
                background: var(--bg-tertiary);
                border-radius: 8px;
                border: 1px solid var(--border);
            `;
            
            actionsDiv.innerHTML = `
                <div style="margin-bottom: 10px; font-weight: 600; color: var(--text-primary);">
                    🛠️ Actions administrateur
                </div>
                <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                    <button onclick="acceptFeedback('${realMessageId}', '${message.feedback.id}', '${message.feedback.userId}')" 
                            style="background: #10b981; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        ✅ Accepter
                    </button>
                    <button onclick="rejectFeedback('${realMessageId}', '${message.feedback.id}', '${message.feedback.userId}')" 
                            style="background: #ef4444; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        ❌ Refuser
                    </button>
                    <button onclick="pendingFeedback('${realMessageId}', '${message.feedback.id}')" 
                            style="background: #f59e0b; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        ⏳ En attente
                    </button>
                    <button onclick="replyToFeedback('${message.feedback.userId}', '${message.feedback.id}')" 
                            style="background: var(--primary); color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        💬 Répondre
                    </button>
                </div>
            `;
            
            messageElement.appendChild(actionsDiv);
        }


        // Fonction pour répondre à un feedback
        async function replyToFeedback(userId, feedbackId) {
            const response = prompt('Tapez votre réponse personnalisée :');
            if (!response || response.trim() === '') return;
            
            try {
                showNotification('📤 Envoi de la réponse...', 'info');
                
                await sendFeedbackResponse(userId, feedbackId, 'custom', response);
                
                showNotification('✅ Réponse envoyée !', 'success');
                
            } catch (error) {
                console.error('Erreur envoi réponse:', error);
                showNotification('Erreur lors de l\'envoi', 'error');
            }
        }
        function initializeFeedbackCounter() {
            const feedbackTextarea = document.getElementById('feedbackText');
            const charCount = document.getElementById('charCount');
            const sendBtn = document.getElementById('sendFeedbackBtn');
            
            if (feedbackTextarea && charCount && sendBtn) {
                // Réinitialiser les valeurs
                feedbackTextarea.value = '';
                charCount.textContent = '0/50 caractères minimum';
                sendBtn.disabled = true;
                sendBtn.style.background = 'var(--bg-secondary)';
                sendBtn.style.color = 'var(--text-secondary)';
                sendBtn.style.cursor = 'not-allowed';
                
                // Ajouter l'event listener pour le compteur
                feedbackTextarea.oninput = function() {
                    const length = this.value.length;
                    charCount.textContent = `${length}/50 caractères minimum`;
                    
                    if (length >= 50) {
                        charCount.style.color = 'var(--success, #10b981)';
                        sendBtn.disabled = false;
                        sendBtn.style.background = 'var(--primary, #667eea)';
                        sendBtn.style.color = 'white';
                        sendBtn.style.cursor = 'pointer';
                    } else {
                        charCount.style.color = 'var(--text-secondary)';
                        sendBtn.disabled = true;
                        sendBtn.style.background = 'var(--bg-secondary)';
                        sendBtn.style.color = 'var(--text-secondary)';
                        sendBtn.style.cursor = 'not-allowed';
                    }
                };
            }
        }
        // ✅ Version corrigée de parseMarkdown
        function parseMarkdown(text) {
            if (!text || typeof text !== 'string') return text;

            let html = text;
            
            // ✅ 1. PROTÉGER LES URLS EN TOUT PREMIER
            const urlRegex = /(https?:\/\/[^\s<>]+)/g;
            html = html.replace(urlRegex, (url) => {
                const cleanUrl = url.replace(/[.,;:!?]+$/, '');
                
                if (isImageUrl(cleanUrl)) {
                    return `§§§IMAGE§§§${cleanUrl}§§§ENDIMAGE§§§`;
                } else if (isGifUrl(cleanUrl)) {
                    return `§§§GIF§§§${cleanUrl}§§§ENDGIF§§§`;
                } else if (isVideoUrl(cleanUrl)) {
                    return `§§§VIDEO§§§${cleanUrl}§§§ENDVIDEO§§§`;
                } else {
                    return `§§§LINK§§§${cleanUrl}§§§ENDLINK§§§`;
                }
            });
            
            // 2. Échapper HTML
            html = html.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            
            // 3. Code blocs multilignes
            html = html.replace(/``````/g, function(match, lang, code) {
                const language = lang || 'text';
                return `<pre style="background: var(--bg-tertiary); color: var(--text-primary); padding: 12px; border-radius: 8px; margin: 10px 0; overflow-x: auto; font-family: 'Courier New', monospace; border: 1px solid var(--border);"><code>${code.trim()}</code></pre>`;
            });
            
            // 4. Code inline
            html = html.replace(/`([^`]+)`/g, '<code style="background: var(--bg-tertiary); padding: 3px 6px; border-radius: 4px; font-family: monospace; font-size: 0.9em; color: var(--primary); border: 1px solid var(--border);">$1</code>');
            
            // 5. Lignes de séparation
            html = html.replace(/^-{3,}\s*$/gm, '___HR_LINE___');
            html = html.replace(/^\*{3,}\s*$/gm, '___HR_STARS___');
            
            // 6. Traitement ligne par ligne
            const lines = html.split('\n');
            let result = [];
            let inUlList = false;
            let inOlList = false;
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                
                if (line.trim() === '___HR_LINE___') {
                    if (inUlList) { result.push('</ul>'); inUlList = false; }
                    if (inOlList) { result.push('</ol>'); inOlList = false; }
                    line = '<hr style="border: none; border-top: 2px solid var(--border); margin: 16px 0; opacity: 0.7;">';
                }
                else if (line.trim() === '___HR_STARS___') {
                    if (inUlList) { result.push('</ul>'); inUlList = false; }
                    if (inOlList) { result.push('</ol>'); inOlList = false; }
                    line = '<hr style="border: none; border-top: 1px solid var(--primary); margin: 16px 0; opacity: 0.9;">';
                }
                else if (line.match(/^&gt;\s*(.+)/)) {
                    const content = line.replace(/^&gt;\s*/, '');
                    line = `<blockquote style="border-left: 4px solid var(--primary); padding: 12px 12px 12px 20px; margin: 12px 0; color: var(--text-secondary); font-style: italic; background: var(--bg-tertiary); border-radius: 0 8px 8px 0; display: block;">${content}</blockquote>`;
                }
                else if (line.match(/^[-*]\s+(.+)/)) {
                    const content = line.replace(/^[-*]\s+/, '');
                    if (!inUlList) {
                        if (inOlList) { result.push('</ol>'); inOlList = false; }
                        result.push('<ul style="margin: 10px 0; padding-left: 20px; color: var(--text-primary);">');
                        inUlList = true;
                    }
                    line = `<li style="margin: 4px 0; line-height: 1.5;">${content}</li>`;
                }
                else if (line.match(/^\d+\.\s+(.+)/)) {
                    const content = line.replace(/^\d+\.\s+/, '');
                    if (!inOlList) {
                        if (inUlList) { result.push('</ul>'); inUlList = false; }
                        result.push('<ol style="margin: 10px 0; padding-left: 20px; color: var(--text-primary);">');
                        inOlList = true;
                    }
                    line = `<li style="margin: 4px 0; line-height: 1.5;">${content}</li>`;
                }
                else {
                    if (inUlList && line.trim() !== '' && !line.includes('___HR_')) {
                        result.push('</ul>'); inUlList = false;
                    }
                    if (inOlList && line.trim() !== '' && !line.includes('___HR_')) {
                        result.push('</ol>'); inOlList = false;
                    }
                }
                
                result.push(line);
            }
            
            if (inUlList) result.push('</ul>');
            if (inOlList) result.push('</ol>');
            
            html = result.join('\n');
            
            // 7. Titres
            html = html.replace(/^#{6}\s+(.+)$/gm, '<h6 style="font-size: 14px; font-weight: 600; margin: 12px 0 8px 0; color: var(--text-primary); line-height: 1.4;">$1</h6>');
            html = html.replace(/^#{5}\s+(.+)$/gm, '<h5 style="font-size: 16px; font-weight: 600; margin: 14px 0 8px 0; color: var(--text-primary); line-height: 1.4;">$1</h5>');
            html = html.replace(/^#{4}\s+(.+)$/gm, '<h4 style="font-size: 18px; font-weight: 600; margin: 16px 0 8px 0; color: var(--text-primary); line-height: 1.4;">$1</h4>');
            html = html.replace(/^#{3}\s+(.+)$/gm, '<h3 style="font-size: 20px; font-weight: 600; margin: 18px 0 8px 0; color: var(--text-primary); line-height: 1.4;">$1</h3>');
            html = html.replace(/^#{2}\s+(.+)$/gm, '<h2 style="font-size: 22px; font-weight: 700; margin: 20px 0 10px 0; color: var(--text-primary); line-height: 1.4;">$1</h2>');
            html = html.replace(/^#{1}\s+(.+)$/gm, '<h1 style="font-size: 24px; font-weight: 700; margin: 22px 0 12px 0; color: var(--text-primary); line-height: 1.4;">$1</h1>');
            
            // 8. Formatage inline (avec exclusion des placeholders)
            html = html.replace(/\*\*([^*\n]+)\*\*/g, '<strong style="font-weight: 700; color: var(--text-primary);">$1</strong>');
            html = html.replace(/(?<!\*)\*([^*\n]+)\*(?!\*)/g, '<em style="font-style: italic; color: var(--text-primary);">$1</em>');
            
            // ✅ EXCLUSION SIMPLE pour le soulignement - éviter les placeholders
            html = html.replace(/__([^_§]+)__/g, function(match, content) {
                // Si le contenu contient un placeholder, on ne fait rien
                if (content.includes('§§§')) {
                    return match;
                }
                return '<u style="text-decoration: underline; color: var(--text-primary);">' + content + '</u>';
            });
            
            html = html.replace(/~~([^~\n]+)~~/g, '<del style="text-decoration: line-through; opacity: 0.7; color: var(--text-secondary);">$1</del>');
            
            // 9. Liens et images markdown
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color: var(--primary); text-decoration: underline; font-weight: 500;">$1</a>');
            html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width: 100%; height: auto; border-radius: 8px; margin: 10px 0; cursor: pointer;">');
            
            // 10. Hashtags
            html = html.replace(/#([a-zA-Z0-9_]+)/g, '<span style="color: var(--primary); font-weight: 600; cursor: pointer; background: rgba(102, 126, 234, 0.1); padding: 2px 6px; border-radius: 4px;" onclick="searchHashtag && searchHashtag(\'$1\', event)">#$1</span>');

            // ✅ 11. RECONVERTIR LES PLACEHOLDERS ULTRA-SÉCURISÉS
            html = html.replace(/§§§IMAGE§§§([^§]+)§§§ENDIMAGE§§§/g, (match, url) => {
                return `<div style="margin: 12px 0; text-align: center;"><img src="${url}" onclick="openImageModal('${url}')" style="max-width: 100%; max-height: 250px; object-fit: contain; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" onerror="this.style.display='none'"></div>`;
            });

            html = html.replace(/§§§GIF§§§([^§]+)§§§ENDGIF§§§/g, (match, url) => {
                return `<div style="margin: 12px 0; text-align: center; position: relative; display: inline-block;">
                    <img src="${url}" onclick="openImageModal('${url}')" style="max-width: 100%; max-height: 250px; object-fit: contain; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" onerror="this.style.display='none'">
                    <div style="position: absolute; top: 8px; left: 8px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">GIF</div>
                </div>`;
            });

            html = html.replace(/§§§VIDEO§§§([^§]+)§§§ENDVIDEO§§§/g, (match, url) => {
                return `<div style="margin: 12px 0; text-align: center;">
                    <video controls style="max-width: 100%; max-height: 300px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                        <source src="${url}" type="video/mp4">
                        Votre navigateur ne supporte pas la lecture vidéo.
                    </video>
                </div>`;
            });

            html = html.replace(/§§§LINK§§§([^§]+)§§§ENDLINK§§§/g, (match, url) => {
                return `<a href="#" onclick="showExternalLinkPopup('${url}'); return false;" style="color: var(--primary); text-decoration: underline; font-weight: 500; cursor: pointer;">🔗 ${url}</a>`;
            });

            // 12. Retours à la ligne
            html = html.replace(/\n/g, '<br>');
            
            return html;
        }





        function searchHashtag(tag, event) {
            // Fermer le menu précédent s'il existe
            if (currentHashtagMenu) {
                currentHashtagMenu.remove();
                currentHashtagMenu = null;
            }
            
            // Empêcher la propagation de l'event
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Créer le menu
            const menu = document.createElement('div');
            menu.className = 'hashtag-menu';
            menu.style.cssText = `
                position: fixed;
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 8px;
                z-index: 9999;
                box-shadow: 0 8px 25px rgba(0,0,0,0.2);
                min-width: 200px;
                backdrop-filter: blur(10px);
                animation: menuSlideIn 0.2s ease-out;
            `;
            
            menu.innerHTML = `
                <div class="hashtag-menu-header" style="padding: 8px 12px; font-weight: 600; color: var(--primary); border-bottom: 1px solid var(--border); margin-bottom: 4px; font-size: 14px;">
                    #${tag}
                </div>
                
                <div class="hashtag-menu-item" onclick="copyHashtag('${tag}')" 
                    style="padding: 10px 12px; cursor: pointer; border-radius: 8px; transition: all 0.2s; display: flex; align-items: center; gap: 10px; font-size: 13px;"
                    onmouseover="this.style.background='var(--bg-tertiary)'"
                    onmouseout="this.style.background='transparent'">
                    <span style="font-size: 16px;">📋</span>
                    <div>
                        <div style="font-weight: 500;">Copier le hashtag</div>
                        <div style="font-size: 11px; color: var(--text-secondary);">Copier #${tag} dans le presse-papiers</div>
                    </div>
                </div>
                
                <div class="hashtag-menu-item" onclick="searchInConversation('${tag}')" 
                    style="padding: 10px 12px; cursor: pointer; border-radius: 8px; transition: all 0.2s; display: flex; align-items: center; gap: 10px; font-size: 13px;"
                    onmouseover="this.style.background='var(--bg-tertiary)'"
                    onmouseout="this.style.background='transparent'">
                    <span style="font-size: 16px;">🔍</span>
                    <div>
                        <div style="font-weight: 500;">Chercher dans la conversation</div>
                        <div style="font-size: 11px; color: var(--text-secondary);">Trouver tous les messages avec ce hashtag</div>
                    </div>
                </div>
                
                <div class="hashtag-menu-item" onclick="addToMessage('${tag}')" 
                    style="padding: 10px 12px; cursor: pointer; border-radius: 8px; transition: all 0.2s; display: flex; align-items: center; gap: 10px; font-size: 13px;"
                    onmouseover="this.style.background='var(--bg-tertiary)'"
                    onmouseout="this.style.background='transparent'">
                    <span style="font-size: 16px;">✏️</span>
                    <div>
                        <div style="font-weight: 500;">Ajouter à mon message</div>
                        <div style="font-size: 11px; color: var(--text-secondary);">Insérer dans la barre de saisie</div>
                    </div>
                </div>
                
                <div class="hashtag-menu-item" onclick="createHashtagFilter('${tag}')" 
                    style="padding: 10px 12px; cursor: pointer; border-radius: 8px; transition: all 0.2s; display: flex; align-items: center; gap: 10px; font-size: 13px;"
                    onmouseover="this.style.background='var(--bg-tertiary)'"
                    onmouseout="this.style.background='transparent'">
                    <span style="font-size: 16px;">🏷️</span>
                    <div>
                        <div style="font-weight: 500;">Filtrer par hashtag</div>
                        <div style="font-size: 11px; color: var(--text-secondary);">Afficher seulement les messages avec #${tag}</div>
                    </div>
                </div>
                
                <div style="border-top: 1px solid var(--border); margin: 4px 0; padding-top: 4px;">
                    <div class="hashtag-menu-item" onclick="closeHashtagMenu()" 
                        style="padding: 8px 12px; cursor: pointer; border-radius: 8px; transition: all 0.2s; text-align: center; font-size: 12px; color: var(--text-secondary);"
                        onmouseover="this.style.background='var(--bg-tertiary)'"
                        onmouseout="this.style.background='transparent'">
                        ✕ Fermer
                    </div>
                </div>
            `;
            
            // Positionner le menu près du curseur
            const rect = event ? event.target.getBoundingClientRect() : { left: 100, top: 100 };
            menu.style.left = `${rect.left}px`;
            menu.style.top = `${rect.bottom + 5}px`;
            
            // Ajuster si le menu sort de l'écran
            document.body.appendChild(menu);
            const menuRect = menu.getBoundingClientRect();
            
            if (menuRect.right > window.innerWidth) {
                menu.style.left = `${window.innerWidth - menuRect.width - 10}px`;
            }
            if (menuRect.bottom > window.innerHeight) {
                menu.style.top = `${rect.top - menuRect.height - 5}px`;
            }
            
            currentHashtagMenu = menu;
            
            // Fermer le menu si on clique ailleurs
            setTimeout(() => {
                document.addEventListener('click', closeHashtagMenu);
            }, 100);
        }

        // ✅ Fonctions pour chaque action du menu
        function copyHashtag(tag) {
            navigator.clipboard.writeText(`#${tag}`).then(() => {
                showNotification(`📋 #${tag} copié !`, 'success');
            }).catch(() => {
                // Fallback pour les navigateurs plus anciens
                const input = document.createElement('input');
                input.value = `#${tag}`;
                document.body.appendChild(input);
                input.select();
                document.execCommand('copy');
                document.body.removeChild(input);
                showNotification(`📋 #${tag} copié !`, 'success');
            });
            closeHashtagMenu();
        }
        function getStatusColor(status) {
            const colors = {
                'Accepté': '#dcfdf7',
                'En attente': '#fef3c7', 
                'Refusé': '#fecaca',
                'Archivé': '#f3f4f6'
            };
            return colors[status] || '#f3f4f6';
        }

        function getStatusTextColor(status) {
            const colors = {
                'Accepté': '#047857',
                'En attente': '#92400e', 
                'Refusé': '#dc2626',
                'Archivé': '#374151'
            };
            return colors[status] || '#374151';
        }

        function getStatusIcon(status) {
            const icons = {
                'Accepté': '✅',
                'En attente': '⏳',
                'Refusé': '❌',
                'Archivé': '📁'
            };
            return icons[status] || '⏳';
        }
        function showCustomReplyForm(userId, feedbackId, messageId) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 3000;
            `;
            
            modal.innerHTML = `
                <div style="background: var(--bg-secondary); border-radius: 16px; padding: 25px; max-width: 500px; width: 90%; box-shadow: 0 25px 50px rgba(0,0,0,0.4);">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; color: var(--text-primary);">💬 Réponse personnalisée</h3>
                        <p style="margin: 8px 0 0; color: var(--text-secondary); font-size: 14px;">ID Feedback: ${feedbackId}</p>
                    </div>
                    
                    <textarea id="customReplyText" placeholder="Tapez votre réponse personnalisée à l'utilisateur..." 
                            style="width: 100%; height: 120px; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); resize: vertical; box-sizing: border-box; font-family: inherit;"></textarea>
                    
                    <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                        💡 <strong>Tip:</strong> Vous pouvez utiliser le Markdown (gras, italique, listes, etc.)
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button onclick="sendCustomReply('${userId}', '${feedbackId}', '${messageId}')" 
                                style="flex: 1; padding: 12px; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            📤 Envoyer la réponse
                        </button>
                        <button onclick="this.closest('[style*=\"z-index: 3000\"]').remove()" 
                                style="padding: 12px 20px; background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                            Annuler
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            document.getElementById('customReplyText').focus();
        }
        async function sendCustomReply(userId, feedbackId, messageId) {
            const replyText = document.getElementById('customReplyText').value.trim();
            
            if (!replyText) {
                showNotification('Veuillez saisir une réponse', 'error');
                return;
            }
            
            try {
                showNotification('📤 Envoi de la réponse...', 'info');
                
                // Créer ou récupérer la conversation avec l'utilisateur
                const userConvRef = db.collection('conversations').doc(`admin_response_${userId}`);
                const userConv = await userConvRef.get();
                
                if (!userConv.exists) {
                    await userConvRef.set({
                        participants: [userId, 'system'],
                        type: 'admin_response',
                        name: '👨‍💼 Réponse Administrative',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastMessage: '',
                        lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                        participantNames: {
                            [userId]: 'Utilisateur',
                            system: 'Administration Ulyra'
                        }
                    });
                }
                
                // Ajouter le message de réponse
                await userConvRef.collection('messages').add({
                    type: 'admin_response',
                    senderId: 'system',
                    senderName: 'Administration Ulyra',
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    text: `👨‍💼 **Réponse à votre feedback** (ID: ${feedbackId})

        ${replyText}

        ---
        *Cette réponse a été envoyée par un administrateur d'Ulyra*`,
                    replyTo: {
                        feedbackId: feedbackId,
                        type: 'feedback_response'
                    }
                });
                
                // Mettre à jour le statut du feedback
                await updateFeedbackStatus(messageId, feedbackId, 'Répondu');
                
                showNotification('✅ Réponse envoyée à l\'utilisateur !', 'success');
                
                // Fermer le modal
                document.querySelector('[style*="z-index: 3000"]').remove();
                
            } catch (error) {
                console.error('Erreur envoi réponse:', error);
                showNotification('Erreur lors de l\'envoi de la réponse', 'error');
            }
        }
        async function updateFeedbackStatus(messageId, feedbackId, newStatus) {
            try {
                await db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .doc(messageId)
                    .update({
                        'actions.status': newStatus,
                        'feedback.status': newStatus,
                        'feedback.processedAt': firebase.firestore.FieldValue.serverTimestamp(),
                        'feedback.processedBy': currentUser.uid
                    });
                
                // Mettre à jour l'affichage du statut
                const statusElement = document.getElementById(`status-${messageId}`);
                if (statusElement) {
                    statusElement.textContent = `${getStatusIcon(newStatus)} ${newStatus}`;
                    statusElement.style.background = getStatusColor(newStatus);
                    statusElement.style.color = getStatusTextColor(newStatus);
                }
                
                showNotification(`Feedback ${newStatus.toLowerCase()}`, 'success');
                
                // Envoyer une réponse automatique selon le statut
                if (newStatus === 'Accepté') {
                    await sendAutoReply(feedbackId, 'accepted');
                } else if (newStatus === 'Refusé') {
                    await sendAutoReply(feedbackId, 'rejected');
                }
                
            } catch (error) {
                console.error('Erreur mise à jour statut:', error);
                showNotification('Erreur lors de la mise à jour', 'error');
            }
        }
        async function sendAutoReply(feedbackId, type) {
            const messages = {
                accepted: `✅ **Feedback accepté !**

        Merci pour votre suggestion ! Elle a été acceptée par notre équipe et sera prise en compte dans les futures mises à jour d'Ulyra.

        Votre contribution nous aide à améliorer la plateforme pour tous les utilisateurs ! 🙏`,

                rejected: `❌ **Feedback examiné**

        Merci d'avoir pris le temps de nous faire un retour. Après examen, cette suggestion ne peut pas être implémentée actuellement.

        Cela ne décourage pas vos futurs feedback - continuez à nous aider à améliorer Ulyra ! 💪`
            };
            
            // Ici tu peux implémenter l'envoi automatique si besoin
            console.log('Réponse automatique:', messages[type]);
        }
        async function acceptFeedback(messageId, feedbackId, userId) {
            console.log('🔍 acceptFeedback appelée avec:', { messageId, feedbackId, userId });
            
            if (!messageId || messageId === 'undefined') {
                showNotification('Erreur: ID de message invalide', 'error');
                return;
            }
            
            try {
                showNotification('✅ Feedback accepté', 'success');
                
                // La notification automatique est envoyée par updateFeedbackInFirestore
                await updateFeedbackInFirestore(messageId, 'Accepté');
                
            } catch (error) {
                console.error('❌ Erreur dans acceptFeedback:', error);
                showNotification('Erreur', 'error');
            }
        }

        async function rejectFeedback(messageId, feedbackId, userId) {
            if (!messageId || messageId === 'undefined') {
                showNotification('Erreur: ID de message invalide', 'error');
                return;
            }
            
            try {
                showNotification('❌ Feedback refusé', 'info');
                await updateFeedbackInFirestore(messageId, 'Refusé');
            } catch (error) {
                console.error('❌ Erreur dans rejectFeedback:', error);
                showNotification('Erreur', 'error');
            }
        }

        async function pendingFeedback(messageId, feedbackId) {
            if (!messageId || messageId === 'undefined') {
                showNotification('Erreur: ID de message invalide', 'error');
                return;
            }
            
            try {
                showNotification('⏳ Feedback mis en attente', 'info');
                await updateFeedbackInFirestore(messageId, 'En attente');
            } catch (error) {
                console.error('❌ Erreur dans pendingFeedback:', error);
                showNotification('Erreur', 'error');
            }
        }
        async function sendFeedbackResponse(userId, feedbackId, type, customMessage = '') {
            const responses = {
                accepted: `✅ **Votre feedback a été accepté !**

        ID: ${feedbackId}

        Merci pour votre suggestion ! Elle a été acceptée par notre équipe et sera prise en compte dans les futures mises à jour d'Ulyra.

        Votre contribution nous aide à améliorer la plateforme ! 🙏`,

                rejected: `❌ **Votre feedback a été examiné**

        ID: ${feedbackId}

        Merci d'avoir pris le temps de nous faire un retour. Après examen, cette suggestion ne peut pas être implémentée actuellement.

        N'hésitez pas à continuer à nous envoyer vos idées ! 💪`,

                custom: `💬 **Réponse à votre feedback**

        ID: ${feedbackId}

        ${customMessage}

        ---
        *Réponse envoyée par l'équipe d'administration d'Ulyra*`
            };
            
            const messageText = responses[type] || responses.custom;
            
            // Créer conversation de réponse avec l'utilisateur
            const responseConvRef = db.collection('conversations').doc(`admin_response_${userId}`);
            
            // Créer la conversation si elle n'existe pas
            const convExists = await responseConvRef.get();
            if (!convExists.exists) {
                await responseConvRef.set({
                    participants: [userId, 'system'],
                    type: 'admin_response',
                    name: '👨‍💼 Réponses Administratives',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: '',
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                    participantNames: {
                        [userId]: 'Utilisateur',
                        system: 'Administration Ulyra'
                    }
                });
            }
            
            // Ajouter le message de réponse
            await responseConvRef.collection('messages').add({
                type: 'admin_response',
                senderId: 'system',
                senderName: 'Administration Ulyra',
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                text: messageText,
                feedbackReference: {
                    feedbackId: feedbackId,
                    responseType: type
                }
            });
            
            // Mettre à jour la dernière activité
            await responseConvRef.update({
                lastMessage: 'Nouvelle réponse administrative',
                lastMessageTime: firebase.firestore.FieldValue.serverTimestamp()
            });
        }
        async function updateFeedbackInFirestore(messageId, newStatus) {
            console.log('🔍 updateFeedbackInFirestore appelée avec:', { messageId, newStatus });
            
            if (!messageId || messageId === 'undefined') {
                console.error('❌ messageId invalide:', messageId);
                showNotification('Erreur: ID de message invalide', 'error');
                return;
            }
            
            try {
                const messageRef = db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .doc(messageId);
                
                // Récupérer le document avant de le mettre à jour pour avoir les infos utilisateur
                const messageDoc = await messageRef.get();
                if (!messageDoc.exists) {
                    console.error('❌ Document message introuvable:', messageId);
                    showNotification('Erreur: Message introuvable', 'error');
                    return;
                }
                
                const messageData = messageDoc.data();
                const userId = messageData.feedback?.userId;
                const feedbackId = messageData.feedback?.id;
                const userName = messageData.feedback?.userName || 'Utilisateur';
                
                console.log('🔍 Données feedback:', { userId, feedbackId, userName });
                
                // Mettre à jour le statut
                await messageRef.update({
                    'feedback.status': newStatus,
                    'feedback.processedAt': firebase.firestore.FieldValue.serverTimestamp(),
                    'feedback.processedBy': currentUser.uid
                });
                
                console.log('✅ Statut mis à jour, envoi de la notification...');
                
                // ✅ ENVOYER UNE RÉPONSE AUTOMATIQUE À L'UTILISATEUR
                if (userId && feedbackId) {
                    await sendAutomaticFeedbackResponse(userId, feedbackId, newStatus, userName);
                    console.log('✅ Notification envoyée à l\'utilisateur');
                } else {
                    console.warn('⚠️ Impossible d\'envoyer la notification : données utilisateur manquantes');
                }
                
                console.log('✅ Feedback mis à jour:', { messageId, newStatus });
                
            } catch (error) {
                console.error('❌ Erreur mise à jour Firestore:', error);
                showNotification('Erreur lors de la mise à jour', 'error');
            }
        }
        async function sendAutomaticFeedbackResponse(userId, feedbackId, status, userName) {
            console.log('📨 Envoi réponse automatique à:', { userId, feedbackId, status });
            
            try {
                // Messages selon le statut
                const autoResponses = {
                    'Accepté': {
                        text: `✅ **Votre feedback a été accepté !**

        ID: ${feedbackId}

        Bonjour ${userName},

        Excellente nouvelle ! Votre suggestion a été acceptée par notre équipe et sera prise en compte dans les futures mises à jour d'Ulyra.

        Merci beaucoup pour votre contribution qui nous aide à améliorer la plateforme ! 🙏

        ---
        *Message automatique du système Ulyra*`,
                        icon: '✅'
                    },
                    
                    'Refusé': {
                        text: `❌ **Votre feedback a été examiné**

        ID: ${feedbackId}

        Bonjour ${userName},

        Merci d'avoir pris le temps de nous faire un retour. Après examen approfondi, cette suggestion ne peut pas être implémentée actuellement pour des raisons techniques ou stratégiques.

        Cela ne décourage pas vos futurs feedback - continuez à nous aider à améliorer Ulyra ! 💪

        ---
        *Message automatique du système Ulyra*`,
                        icon: '❌'
                    },
                    
                    'En attente': {
                        text: `⏳ **Votre feedback est en cours d'examen**

        ID: ${feedbackId}

        Bonjour ${userName},

        Votre suggestion est actuellement en cours d'examen par notre équipe. Nous prenons le temps d'analyser chaque retour avec attention.

        Vous recevrez une nouvelle notification dès qu'une décision sera prise.

        Merci pour votre patience ! 🤝

        ---
        *Message automatique du système Ulyra*`,
                        icon: '⏳'
                    },
                    
                    'Archivé': {
                        text: `📁 **Votre feedback a été archivé**

        ID: ${feedbackId}

        Bonjour ${userName},

        Votre feedback a été archivé après traitement. Cela peut signifier qu'il a été noté pour référence future ou qu'il ne nécessite pas d'action immédiate.

        Merci pour votre contribution ! 📝

        ---
        *Message automatique du système Ulyra*`,
                        icon: '📁'
                    }
                };
                
                const response = autoResponses[status] || {
                    text: `ℹ️ **Statut de votre feedback mis à jour**

        ID: ${feedbackId}

        Bonjour ${userName},

        Le statut de votre feedback est maintenant : **${status}**

        ---
        *Message automatique du système Ulyra*`,
                    icon: 'ℹ️'
                };
                
                // Créer ou récupérer la conversation de réponse avec l'utilisateur
                const responseConvId = `admin_response_${userId}`;
                const responseConvRef = db.collection('conversations').doc(responseConvId);
                const userConv = await responseConvRef.get();
                
                // Créer la conversation si elle n'existe pas
                if (!userConv.exists) {
                    console.log('📝 Création de la conversation de réponse');
                    await responseConvRef.set({
                        participants: [userId, 'system'],
                        type: 'admin_response',
                        name: '👨‍💼 Réponses Administratives',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastMessage: '',
                        lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                        participantNames: {
                            [userId]: userName,
                            system: 'Administration Ulyra'
                        }
                    });
                }
                
                // Ajouter le message de réponse
                await responseConvRef.collection('messages').add({
                    type: 'admin_response',
                    senderId: 'system',
                    senderName: 'Administration Ulyra',
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    text: response.text,
                    feedbackReference: {
                        feedbackId: feedbackId,
                        responseType: 'automatic',
                        status: status
                    }
                });
                
                // Mettre à jour la dernière activité de la conversation
                await responseConvRef.update({
                    lastMessage: `${response.icon} Feedback ${status.toLowerCase()}`,
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                console.log('✅ Réponse automatique envoyée avec succès');
                
            } catch (error) {
                console.error('❌ Erreur envoi réponse automatique:', error);
                throw error; // Relancer l'erreur pour que l'appelant soit au courant
            }
        }
        function searchInConversation(tag) {
            const messages = document.querySelectorAll('.message');
            let found = [];
            
            // Retirer les surlignages précédents
            messages.forEach(msg => {
                msg.style.background = '';
                msg.style.border = '';
            });
            
            // Chercher les messages contenant le hashtag
            messages.forEach(msg => {
                const textContent = msg.textContent.toLowerCase();
                if (textContent.includes(`#${tag.toLowerCase()}`)) {
                    found.push(msg);
                }
            });
            
            if (found.length > 0) {
                showNotification(`🔍 ${found.length} message(s) trouvé(s) avec #${tag}`, 'success');
                
                // Surligner les messages trouvés
                found.forEach((msg, index) => {
                    setTimeout(() => {
                        msg.style.background = 'rgba(102, 126, 234, 0.1)';
                        msg.style.border = '2px solid var(--primary)';
                        msg.style.borderRadius = '8px';
                        msg.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, index * 200);
                });
                
                // Retirer le surlignage après 5 secondes
                setTimeout(() => {
                    found.forEach(msg => {
                        msg.style.background = '';
                        msg.style.border = '';
                    });
                }, 5000);
            } else {
                showNotification(`🔍 Aucun message trouvé avec #${tag}`, 'info');
            }
            
            closeHashtagMenu();
        }

        function addToMessage(tag) {
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                const currentValue = messageInput.value;
                const cursorPos = messageInput.selectionStart;
                
                // Ajouter le hashtag à la position du curseur
                const newValue = currentValue.slice(0, cursorPos) + `#${tag} ` + currentValue.slice(cursorPos);
                messageInput.value = newValue;
                
                // Repositionner le curseur
                const newCursorPos = cursorPos + tag.length + 2;
                messageInput.setSelectionRange(newCursorPos, newCursorPos);
                messageInput.focus();
                
                showNotification(`✏️ #${tag} ajouté à votre message`, 'success');
            }
            closeHashtagMenu();
        }

        function createHashtagFilter(tag) {
            const messages = document.querySelectorAll('.message');
            let visibleCount = 0;
            
            messages.forEach(msg => {
                const textContent = msg.textContent.toLowerCase();
                if (textContent.includes(`#${tag.toLowerCase()}`)) {
                    msg.style.display = '';
                    visibleCount++;
                } else {
                    msg.style.display = 'none';
                }
            });
            
            showNotification(`🏷️ Filtre appliqué : ${visibleCount} message(s) avec #${tag}`, 'info');
            
            // Ajouter un bouton pour retirer le filtre
            setTimeout(() => {
                const filterNotice = document.createElement('div');
                filterNotice.id = 'hashtag-filter-notice';
                filterNotice.style.cssText = `
                    position: fixed;
                    top: 70px;
                    right: 20px;
                    background: var(--primary);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 8px;
                    font-size: 13px;
                    z-index: 1000;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                `;
                filterNotice.innerHTML = `
                    🏷️ Filtre: #${tag} 
                    <button onclick="removeHashtagFilter()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 4px 8px; border-radius: 4px; margin-left: 8px; cursor: pointer;">
                        ✕ Tout afficher
                    </button>
                `;
                document.body.appendChild(filterNotice);
            }, 1000);
            
            closeHashtagMenu();
        }

        function removeHashtagFilter() {
            const messages = document.querySelectorAll('.message');
            messages.forEach(msg => {
                msg.style.display = '';
            });
            
            const filterNotice = document.getElementById('hashtag-filter-notice');
            if (filterNotice) {
                filterNotice.remove();
            }
            
            showNotification('🏷️ Filtre retiré - tous les messages affichés', 'success');
        }

        function closeHashtagMenu() {
            if (currentHashtagMenu) {
                currentHashtagMenu.remove();
                currentHashtagMenu = null;
            }
            document.removeEventListener('click', closeHashtagMenu);
        }
        function resetMessageInputHeight() {
            const input = document.getElementById('messageInput');
            if (!input) return;
            
            // Vider le contenu
            input.value = '';
            
            // Réinitialiser la hauteur
            input.style.height = 'auto';
            input.style.height = ''; // Revenir au CSS par défaut
            
            // Ou forcer à une hauteur minimale spécifique
            // input.style.height = '40px'; // Ajuste selon ta hauteur normale
        }

        function addReaction(messageId, emoji) {
            toggleReaction(messageId, emoji);
            closeReactionMenu();
        }
        function showReactionPicker(messageId, event) {
            console.log('showReactionPicker appelée');
            
            // Supprimer l'ancien menu
            const oldMenu = document.querySelector('.reaction-menu');
            if (oldMenu) oldMenu.remove();
            
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            // Trouver le message
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageElement) {
                console.error('Message non trouvé:', messageId);
                return;
            }
            
            messageElement.style.position = 'relative';
            
            // Liste d'émojis ÉTENDUE pour le scroll
            const allReactions = [
                '😀','😃','😄','😁','😊','😍','🥰','😘','😂','🤣','😊','😇','🙂','😉','😌','😋',
                '😎','🤔','🤯','😱','😭','😢','😤','😡','👍','👎','👏','🙌','👌','✋','👋','🤝',
                '❤️','💙','💚','💛','🧡','💜','🖤','💔','🔥','💯','⭐','✨','💎','🎉','🎊','🚀'
            ];
            
            // Organiser en 3 lignes
            const reactions = [
                allReactions.slice(0, 16),  // Ligne 1
                allReactions.slice(16, 32), // Ligne 2
                allReactions.slice(32, 48)  // Ligne 3
            ];
            
            // Créer le menu
            const menu = document.createElement('div');
            menu.className = 'reaction-menu';
            
            // Header simple
            const header = document.createElement('div');
            header.style.cssText = `
                padding: 8px 12px;
                font-weight: 600;
                color: var(--primary);
                border-bottom: 1px solid var(--border);
                margin-bottom: 8px;
                font-size: 14px;
                text-align: center;
            `;
            header.textContent = '😊 Réactions';
            menu.appendChild(header);
            
            // Container principal avec bouton fixe + zone scrollable
            const mainContainer = document.createElement('div');
            mainContainer.style.cssText = `
                padding: 8px 12px;
                display: flex;
                align-items: flex-start;
                gap: 8px;
            `;
            
            // ✅ BOUTON FERMER FIXE (ne scroll pas)
            const closeBtn = document.createElement('div');
            closeBtn.style.cssText = `
                background: #6b7280;
                border: 2px solid #ef4444;
                border-radius: 6px;
                cursor: pointer;
                padding: 6px;
                text-align: center;
                font-size: 12px;
                font-weight: 600;
                color: white;
                transition: all 0.3s ease;
                user-select: none;
                min-width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-shrink: 0;
            `;
            closeBtn.textContent = '✕';
            closeBtn.onmouseover = () => {
                closeBtn.style.background = '#ef4444';
                closeBtn.style.transform = 'scale(1.1)'; // Juste le scale, pas de rotation
                closeBtn.style.borderColor = '#dc2626';
            };
            closeBtn.onmouseout = () => {
                closeBtn.style.background = '#6b7280';
                closeBtn.style.transform = 'scale(1)'; // Retour à la taille normale
                closeBtn.style.borderColor = '#ef4444';
            };
            closeBtn.onclick = () => menu.remove();
            mainContainer.appendChild(closeBtn);
            
            // ✅ ZONE SCROLLABLE POUR LES 3 LIGNES
            const scrollContainer = document.createElement('div');
            scrollContainer.style.cssText = `
                overflow-x: auto;
                overflow-y: hidden;
                max-width: 240px;
                scrollbar-width: thin;
                scrollbar-color: var(--border) transparent;
            `;
            
            // Grid pour les 3 lignes d'emojis
            const emojiGrid = document.createElement('div');
            emojiGrid.style.cssText = `
                display: grid;
                grid-template-rows: repeat(3, 1fr);
                gap: 4px;
                min-width: max-content;
                padding: 4px;
            `;
            
            // ✅ CRÉER LES 3 LIGNES
            reactions.forEach((lineReactions, lineIndex) => {
                const line = document.createElement('div');
                line.style.cssText = `
                    display: flex;
                    gap: 6px;
                    align-items: center;
                `;
                
                lineReactions.forEach(emoji => {
                    const emojiBtn = document.createElement('span');
                    emojiBtn.textContent = emoji;
                    emojiBtn.style.cssText = `
                        font-size: 18px;
                        cursor: pointer;
                        padding: 4px;
                        border-radius: 6px;
                        transition: all 0.2s;
                        text-align: center;
                        user-select: none;
                        min-width: 28px;
                        height: 28px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-shrink: 0;
                    `;
                    
                    emojiBtn.onmouseover = () => {
                        emojiBtn.style.background = 'var(--bg-tertiary)';
                        emojiBtn.style.transform = 'scale(1.2)';
                    };
                    emojiBtn.onmouseout = () => {
                        emojiBtn.style.background = 'transparent';
                        emojiBtn.style.transform = 'scale(1)';
                    };
                    
                    emojiBtn.onclick = () => {
                        toggleReaction(messageId, emoji);
                        menu.remove();
                    };
                    
                    line.appendChild(emojiBtn);
                });
                
                emojiGrid.appendChild(line);
            });
            
            scrollContainer.appendChild(emojiGrid);
            mainContainer.appendChild(scrollContainer);
            menu.appendChild(mainContainer);
            
            // Style du menu
            menu.style.cssText = `
                position: absolute;
                background: var(--bg-secondary);
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 8px;
                z-index: 9999;
                box-shadow: 0 8px 25px rgba(0,0,0,0.2);
                backdrop-filter: blur(10px);
                animation: menuSlideIn 0.2s ease-out;
                left: 0px;
                top: 100%;
                margin-top: 5px;
            `;
            
            // Ajouter au message
            messageElement.appendChild(menu);
            
            // ✅ SCROLL HORIZONTAL avec la molette
            scrollContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                scrollContainer.scrollLeft += e.deltaY > 0 ? 30 : -30;
            });
            
            console.log('Menu 3 lignes avec scroll horizontal créé');
            
            // Fermer si clic ailleurs
            setTimeout(() => {
                document.addEventListener('click', (e) => {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                    }
                });
            }, 100);
        }
        const messageSpacingStyle = document.createElement('style');
        messageSpacingStyle.textContent = `
            .message {
                margin-bottom: 10px !important;
            }
        `;
        document.head.appendChild(messageSpacingStyle);

        function detectAndCreateLinks(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            
            return text.replace(urlRegex, (url) => {
                const cleanUrl = url.replace(/[.,;:!?]+$/, '');
                
                if (isImageUrl(cleanUrl)) {
                    return createImageEmbed(cleanUrl);
                } else if (isVideoUrl(cleanUrl)) {
                    return createVideoEmbed(cleanUrl);
                } else if (isGifUrl(cleanUrl)) {
                    return createGifEmbed(cleanUrl);
                } else {
                    return createExternalLink(cleanUrl);
                }
            });
        }


        // ✅ Fonctions pour détecter les types de médias
        function isImageUrl(url) {
            return /\.(jpg|jpeg|png|webp|svg|bmp)(\?.*)?$/i.test(url) || 
                /unsplash\.com/i.test(url) ||
                url.includes('fm=jpg') || url.includes('format=jpg');
        }

        function isVideoUrl(url) {
            return /\.(mp4|webm|ogg|avi|mov)(\?.*)?$/i.test(url);
        }

        function isGifUrl(url) {
            return /\.gif(\?.*)?$/i.test(url);
        }

        // ✅ Créer un lien externe avec pop-up de confirmation
        // ✅ Version corrigée du lien externe
        function createExternalLink(url) {
            return `<a href="#" onclick="showExternalLinkPopup('${url}'); return false;" style="color: var(--primary); text-decoration: underline; font-weight: 500; cursor: pointer;">🔗 ${url}</a>`;
        }

        // ✅ Pop-up de confirmation pour liens externes
        function showExternalLinkPopup(url) {
            // Créer le modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                animation: fadeIn 0.3s ease;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: var(--bg-secondary);
                    border: 1px solid var(--border);
                    border-radius: 12px;
                    padding: 24px;
                    max-width: 500px;
                    width: 90%;
                    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                    animation: slideIn 0.3s ease;
                ">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                        <span style="font-size: 24px;">⚠️</span>
                        <h3 style="margin: 0; color: var(--text-primary); font-size: 18px;">Lien externe</h3>
                    </div>
                    
                    <p style="color: var(--text-secondary); margin: 16px 0; line-height: 1.5;">
                        Vous allez quitter <strong>Ulyra</strong> pour accéder à un site externe :
                    </p>
                    
                    <div style="
                        background: var(--bg-tertiary);
                        padding: 12px;
                        border-radius: 8px;
                        margin: 16px 0;
                        word-break: break-all;
                        font-family: monospace;
                        font-size: 14px;
                        color: var(--primary);
                    ">${url}</div>
                    
                    <p style="color: var(--text-secondary); font-size: 13px; margin: 16px 0 20px;">
                        Ulyra n'est pas responsable du contenu des sites externes.
                    </p>
                    
                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button onclick="this.closest('div[style*=\"position: fixed\"]').remove()" 
                                style="
                                    padding: 10px 20px;
                                    background: var(--bg-tertiary);
                                    border: 1px solid var(--border);
                                    border-radius: 8px;
                                    color: var(--text-primary);
                                    cursor: pointer;
                                    transition: all 0.3s;
                                "
                                onmouseover="this.style.background='var(--border)'"
                                onmouseout="this.style.background='var(--bg-tertiary)'">
                            Annuler
                        </button>
                        <button onclick="window.open('${url}', '_blank'); this.closest('div[style*=\"position: fixed\"]').remove()" 
                                style="
                                    padding: 10px 20px;
                                    background: var(--primary);
                                    border: none;
                                    border-radius: 8px;
                                    color: white;
                                    cursor: pointer;
                                    font-weight: 600;
                                    transition: all 0.3s;
                                "
                                onmouseover="this.style.opacity='0.9'"
                                onmouseout="this.style.opacity='1'">
                            Continuer
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Fermer avec Escape
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            // Fermer en cliquant à côté
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }
        function createImageEmbed(url) {
            return `
                <div style="margin: 12px 0;">
                    <img src="${url}" 
                        onclick="openImageModal('${url}')"
                        style="
                            max-width: 100%;
                            max-height: 300px;
                            border-radius: 8px;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                        "
                        onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 8px 20px rgba(0,0,0,0.2)'"
                        onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'"
                        onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                    <div style="display: none; color: var(--text-secondary); font-style: italic; font-size: 14px;">
                        ❌ Impossible de charger l'image
                    </div>
                </div>
            `;
        }

        // ✅ Modal pour agrandir l'image
        function openImageModal(url) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.9); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="position: relative; max-width: 90vw; max-height: 90vh;">
                    <img src="${url}" style="max-width: 100%; max-height: 100%; border-radius: 8px;">
                    <button onclick="this.closest('div').remove()" 
                            style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 20px;">✕</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => e.target === modal && modal.remove();
        }

        // ✅ Fonction pop-up pour liens externes
        function showExternalLinkPopup(url) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            modal.innerHTML = `
                <div style="background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; padding: 24px; max-width: 500px; width: 90%;">
                    <h3 style="margin: 0 0 16px; color: var(--text-primary);">⚠️ Lien externe</h3>
                    <p style="color: var(--text-secondary); margin: 16px 0;">Vous allez quitter Ulyra pour :</p>
                    <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; word-break: break-all; font-family: monospace; font-size: 14px;">${url}</div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
                        <button onclick="this.closest('div').remove()" style="padding: 10px 20px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">Annuler</button>
                        <button onclick="window.open('${url}', '_blank'); this.closest('div').remove()" style="padding: 10px 20px; background: var(--primary); border: none; border-radius: 8px; color: white; cursor: pointer;">Continuer</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.onclick = (e) => e.target === modal && modal.remove();
        }

        // ✅ Animation CSS
        const style = document.createElement('style');
        style.textContent = `
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        `;
        document.head.appendChild(style);
        function createVideoEmbed(url) {
            return `
                <div style="margin: 12px 0;">
                    <video controls 
                        style="
                            width: 100%;
                            max-height: 400px;
                            border-radius: 8px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                        "
                        oncontextmenu="return false;">
                        <source src="${url}" type="video/mp4">
                        <source src="${url}" type="video/webm">
                        <source src="${url}" type="video/ogg">
                        Votre navigateur ne supporte pas la lecture vidéo.
                    </video>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px; text-align: center;">
                        🎬 Vidéo : <a href="${url}" target="_blank" style="color: var(--primary);">${url}</a>
                    </div>
                </div>
            `;
        }
        function createGifEmbed(url) {
            const gifId = 'gif_' + Math.random().toString(36).substr(2, 9);
            
            return `<div style="margin: 12px 0; position: relative; display: inline-block;">
                <img id="${gifId}" src="${url}" style="max-width: 100%; max-height: 300px; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" onclick="toggleGif('${gifId}', '${url}')" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <div style="display: none; color: var(--text-secondary); font-style: italic; font-size: 14px;">❌ Impossible de charger le GIF</div>
                <div style="position: absolute; top: 8px; left: 8px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">GIF</div>
            </div>`;
        }

        // ✅ Fonction pour pause/play des GIFs
        function toggleGif(gifId, originalUrl) {
            const img = document.getElementById(gifId);
            if (!img) return;
            
            if (img.dataset.paused === 'true') {
                // Reprendre le GIF
                img.src = originalUrl;
                img.dataset.paused = 'false';
            } else {
                // Mettre en pause (afficher la première frame)
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.drawImage(img, 0, 0);
                img.src = canvas.toDataURL();
                img.dataset.paused = 'true';
            }
        }
        function addReplyButtonToMessage(messageElement, messageId, messageText, senderName) {
            const replyBtn = messageElement.querySelector('.reply-btn');
            if (replyBtn) {
                replyBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showReplyPreview(messageId, messageText, senderName);
                });
            }
        }
        function clearReplyMode() {
            console.log('🗑️ clearReplyMode, currentReplyId était:', currentReplyId);
            
            currentReplyId = null;
            
            const replyPreview = document.getElementById('reply-preview');
            if (replyPreview) {
                replyPreview.remove();
            }
            
            console.log('✅ Mode réponse nettoyé');
        }
        function handleReplyClick(messageId) {
            console.log('🎯 DÉBUT handleReplyClick avec messageId:', messageId);
            
            if (!messageId) {
                console.error('❌ Pas de messageId fourni');
                return;
            }
            
            // ✅ DONNÉES DE TEST (on va d'abord faire fonctionner avec ça)
            const messageText = "Message test";
            const senderName = "Utilisateur Test";
            
            console.log('📝 Données utilisées:', { messageId, messageText, senderName });
            
            // ✅ Appeler directement showReplyPreview
            showReplyPreview(messageId, messageText, senderName);
        }
        function editMessageFromButton(button) {
            const messageId = button.getAttribute('data-message-id');
            const currentText = button.getAttribute('data-message-text');
            
            console.log('✏️ editMessageFromButton appelée:', { messageId, currentText });
            
            if (!messageId) {
                console.error('❌ messageId manquant dans les attributs du bouton');
                return;
            }
            
            // ✅ Appeler ta fonction editMessage existante
            editMessage(messageId, currentText);
        }
        function deleteMessageFromButton(button, event) {
            // ✅ Empêcher la propagation
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            const messageId = button.getAttribute('data-message-id');
            const messagePreview = button.getAttribute('data-message-preview');
            
            console.log('🗑️ deleteMessageFromButton appelée:', { messageId, messagePreview });
            
            if (!messageId) {
                console.error('❌ messageId manquant dans les attributs du bouton');
                showNotification('Erreur: Impossible de trouver l\'ID du message', 'error');
                return;
            }
            
            // ✅ Désactiver temporairement le bouton pour éviter les double-clics
            button.disabled = true;
            button.style.opacity = '0.5';
            
            // ✅ Appeler la fonction de suppression
            deleteMessage(messageId, messagePreview);
            
            // ✅ Réactiver le bouton après un délai
            setTimeout(() => {
                button.disabled = false;
                button.style.opacity = '1';
            }, 2000);
        }
        function updateRepliesAfterDeletion(deletedMessageId) {
            console.log('🔄 Mise à jour des réponses après suppression:', deletedMessageId);
            
            // ✅ Trouver toutes les reply-bubbles qui référencent ce message
            const replyBubbles = document.querySelectorAll(`[onclick*="scrollToMessage('${deletedMessageId}')"]`);
            
            replyBubbles.forEach(bubble => {
                const replyContent = bubble.querySelector('.reply-content');
                if (replyContent) {
                    // ✅ Remplacer le contenu
                    replyContent.innerHTML = '🗑️ Le message original a été supprimé';
                    replyContent.style.fontStyle = 'italic';
                    replyContent.style.opacity = '0.6';
                    replyContent.style.color = 'var(--text-secondary)';
                    
                    // ✅ Désactiver le clic
                    bubble.style.cursor = 'default';
                    bubble.style.borderLeftColor = 'var(--text-secondary)';
                    bubble.onclick = null;
                    
                    // ✅ Supprimer les effets hover
                    bubble.onmouseover = null;
                    bubble.onmouseout = null;
                    
                    console.log('✅ Reply bubble mise à jour pour message supprimé:', deletedMessageId);
                }
            });
        }
        async function notifyMessageDeletion(deletedMessageId) {
            try {
                // ✅ Ajouter un message système pour notifier la suppression
                const notificationRef = db.collection('conversations')
                    .doc(currentConversation.id)
                    .collection('messages')
                    .doc(); // Nouveau document
                
                await notificationRef.set({
                    type: 'message_deletion_notification',
                    deletedMessageId: deletedMessageId,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    senderId: 'system'
                });
                
                console.log('📢 Notification de suppression envoyée');
                
            } catch (error) {
                console.error('❌ Erreur notification suppression:', error);
            }
        }
        function updateMessageDisplay(messageId, messageData) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                const messageTextElement = messageElement.querySelector('.message-text');
                const messageActionsElement = messageElement.querySelector('.message-actions');
                const messageBubble = messageElement.querySelector('.message-bubble');
                
                if (messageTextElement && messageData.deleted) {
                    // ✅ Changer le contenu
                    messageTextElement.innerHTML = '🗑️ Ce message a été supprimé';
                    messageTextElement.style.fontStyle = 'italic';
                    messageTextElement.style.opacity = '0.7';
                    messageTextElement.style.color = 'var(--text-secondary)';
                    
                    // ✅ Cacher les boutons d'action
                    if (messageActionsElement) {
                        messageActionsElement.style.display = 'none';
                    }
                    
                    // ✅ Styliser la bulle
                    if (messageBubble) {
                        messageBubble.classList.add('deleted-message');
                    }
                    
                    // ✅ Ajouter la classe deleted à l'élément principal
                    messageElement.classList.add('deleted');
                    
                    console.log('✅ Affichage du message supprimé mis à jour:', messageId);
                }
            }
        }
        async function openAnnouncementModal() {
            console.log('📢 Ouverture du modal d\'annonce admin');
            
            // ✅ Vérifier les permissions admin
            if (!isAdmin(currentUser.uid)) {
                showNotification('Accès refusé : Permissions administrateur requises', 'error');
                return;
            }
            
            // ✅ Compter le nombre d'utilisateurs
            try {
                const usersSnapshot = await db.collection('users').get();
                const userCount = usersSnapshot.size;
                document.getElementById('userCount').textContent = userCount;
            } catch (error) {
                console.error('Erreur comptage utilisateurs:', error);
                document.getElementById('userCount').textContent = 'inconnu';
            }
            
            // ✅ Afficher le modal
            const modal = document.getElementById('adminAnnouncementModal');
            modal.style.display = 'flex';
            
            // ✅ Focus sur le textarea
            document.getElementById('announcementMessage').focus();
        }

        // ✅ Fonction pour fermer le popup
        function closeAnnouncementModal() {
            const modal = document.getElementById('adminAnnouncementModal');
            modal.style.display = 'none';
            
            // ✅ Réinitialiser les champs
            document.getElementById('announcementSender').value = 'Ulyra';
            document.getElementById('announcementMessage').value = '';
        }

        // ✅ Fonction principale pour envoyer l'annonce générale
        async function sendGeneralAnnouncement() {
            const senderName = document.getElementById('announcementSender').value.trim();
            const message = document.getElementById('announcementMessage').value.trim();
            const sendBtn = document.getElementById('sendAnnouncementBtn');
            
            // ✅ Validations
            if (!senderName) {
                showNotification('Le nom d\'expéditeur est requis', 'warning');
                return;
            }
            
            if (!message) {
                showNotification('Le message d\'annonce est requis', 'warning');
                return;
            }
            
            if (message.length > 1000) {
                showNotification('Le message est trop long (max 1000 caractères)', 'warning');
                return;
            }
            
            // ✅ Confirmation
            const userCountText = document.getElementById('userCount').textContent;
            if (!confirm(`Confirmer l'envoi de cette annonce à ${userCountText} utilisateurs ?\n\n"${message.substring(0, 100)}${message.length > 100 ? '...' : ''}"`)) {
                return;
            }
            
            // ✅ Désactiver le bouton pendant l'envoi
            sendBtn.disabled = true;
            sendBtn.innerHTML = '⏳ Envoi en cours...';
            
            try {
                console.log('📤 Début envoi annonce générale...');
                
                // ✅ Récupérer tous les utilisateurs
                const usersSnapshot = await db.collection('users').get();
                const users = [];
                
                usersSnapshot.forEach(doc => {
                    const userData = doc.data();
                    if (doc.id !== currentUser.uid) { // Ne pas s'envoyer à soi-même
                        users.push({
                            uid: doc.id,
                            displayName: userData.displayName || userData.name || 'Utilisateur'
                        });
                    }
                });
                
                console.log(`📊 ${users.length} utilisateurs trouvés pour l'annonce`);
                
                // ✅ Envoyer l'annonce à chaque utilisateur (par batch pour éviter les limites)
                const batchSize = 10; // Traiter 10 utilisateurs à la fois
                let successCount = 0;
                let errorCount = 0;
                
                for (let i = 0; i < users.length; i += batchSize) {
                    const batch = users.slice(i, i + batchSize);
                    const promises = batch.map(user => sendAnnouncementToUser(user.uid, senderName, message));
                    
                    const results = await Promise.allSettled(promises);
                    
                    results.forEach((result, index) => {
                        if (result.status === 'fulfilled') {
                            successCount++;
                            console.log(`✅ Annonce envoyée à ${batch[index].displayName}`);
                        } else {
                            errorCount++;
                            console.error(`❌ Erreur envoi à ${batch[index].displayName}:`, result.reason);
                        }
                    });
                    
                    // ✅ Pause courte entre les batches pour éviter la surcharge
                    if (i + batchSize < users.length) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                console.log(`📈 Résultats: ${successCount} succès, ${errorCount} erreurs`);
                
                // ✅ Notification de résultat
                if (errorCount === 0) {
                    showNotification(`✅ Annonce envoyée avec succès à ${successCount} utilisateurs`, 'success');
                } else {
                    showNotification(`⚠️ Annonce envoyée à ${successCount} utilisateurs (${errorCount} erreurs)`, 'warning');
                }
                
                // ✅ Fermer le modal
                closeAnnouncementModal();
                
            } catch (error) {
                console.error('❌ Erreur générale envoi annonce:', error);
                showNotification('Erreur lors de l\'envoi de l\'annonce', 'error');
            } finally {
                // ✅ Réactiver le bouton
                sendBtn.disabled = false;
                sendBtn.innerHTML = '📢 Envoyer l\'annonce';
            }
        }

        // ✅ Fonction pour envoyer l'annonce à un utilisateur spécifique
        async function sendAnnouncementToUser(recipientUid, senderName, message) {
            // ✅ Créer ou récupérer la conversation privée avec cet utilisateur
            const conversationId = await getOrCreatePrivateConversation(currentUser.uid, recipientUid);
            
            if (!conversationId) {
                throw new Error(`Impossible de créer la conversation avec ${recipientUid}`);
            }
            
            // ✅ Envoyer le message d'annonce
            const messageRef = db.collection('conversations')
                .doc(conversationId)
                .collection('messages')
                .doc();
            
            await messageRef.set({
                text: message,
                senderId: currentUser.uid,
                senderDisplayName: senderName, // ✅ Nom personnalisé
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                type: 'announcement',
                isGeneralAnnouncement: true
            });
            
            // ✅ Mettre à jour la conversation
            await db.collection('conversations').doc(conversationId).update({
                lastMessage: `📢 ${message.substring(0, 50)}${message.length > 50 ? '...' : ''}`,
                lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            return conversationId;
        }

        // ✅ Fonction helper pour créer/récupérer une conversation privée
        async function getOrCreatePrivateConversation(user1Uid, user2Uid) {
            try {
                // ✅ Chercher une conversation existante
                const conversationsRef = db.collection('conversations');
                const query = await conversationsRef
                    .where('participants', 'array-contains-any', [user1Uid, user2Uid])
                    .where('type', '==', 'private')
                    .get();
                
                // ✅ Trouver la conversation qui contient exactement ces deux participants
                for (const doc of query.docs) {
                    const data = doc.data();
                    if (data.participants.length === 2 && 
                        data.participants.includes(user1Uid) && 
                        data.participants.includes(user2Uid)) {
                        return doc.id;
                    }
                }
                
                // ✅ Créer une nouvelle conversation si elle n'existe pas
                const newConversationRef = await conversationsRef.add({
                    type: 'private',
                    participants: [user1Uid, user2Uid],
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastMessage: '',
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                return newConversationRef.id;
                
            } catch (error) {
                console.error('Erreur création conversation privée:', error);
                return null;
            }
        }
    </script>
</body>
</html>